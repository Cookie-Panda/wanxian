<html lang="en">
    <!-- Was also known as bibuild before-->
	<head>
<!-- PWA metadata -->
<link rel="manifest" href="manifest.json" />
<meta name="description" content="Wanxian: Biome Generator For Minecraft Bedrock Edition." />
<meta name="theme-color" content="#6750A4" />

<!-- Icons -->
<link rel="icon" href="icons/icon.svg" type="image/svg+xml" />

<!-- PNG fallbacks -->
<link rel="icon" href="icons/icon3.png" sizes="32x32" />
<link rel="icon" href="icons/icon2.png" sizes="192x192" />
<link rel="icon" href="icons/icon1.png" sizes="512x512" />

<!-- iOS -->
<link rel="apple-touch-icon" href="icons/icon-192.png" />
    <!-- iOS Support meta tags (Optional but recommended) -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, shrink-to-fit=no">
		<title>Wanxian - Biome Generator</title>
		<link href="css2.css" rel="stylesheet">
		<link rel="stylesheet" href="styles.css">
		<script src="themes.js"></script>

<script src="presets_data.js"></script>
</script>
</body>
	</head>
	<body>
		<header class="expressive">
		    <div class="top-app-bar">
			<div class="leading-content">
				<div class="title">
					<h1>Wanxian</h1>
				</div>
			</div>
			</div>
			<style>

			</style>
			<div class="trailing-actions">
				<div class="more-options">
					<button class="m3-expressive-tonal-icon-button" id="more-button">
					<span class="material-symbols-rounded" style="font-variation-settings: 'FILL' 0, 'wght' 600, 'GRAD' 0, 'opsz' 24;"></span>
					</button>
					<div class="dropdown-menu" id="dropdown-menu">
						<a href="#" class="list-item" id="theme-toggle">
						<span class="material-symbols-rounded leading-icon">dark_mode</span>
						<span class="list-label">Dark Theme</span>
						<button class="icon-button trailing-icon-button" data-toggled="off">
						<span class="material-symbols-rounded">toggle_off</span>
						</button>
						</a>
						<div class="list-item" id="fullscreenBtn">
							<span class="material-symbols-rounded leading-icon"></span>
							<span class="list-label">Full Screen</span>
						</div>
						<!-- ADDED: Theme Button -->
<a href="#" class="list-item" id="theme-button">
    <span class="material-symbols-rounded leading-icon">palette</span>
    <span class="list-label">Change Theme</span>
</a>
<div class="menu-divider"></div>
<a href="#" class="list-item" id="decorative-presets-toggle">
    <span class="material-symbols-rounded leading-icon">extension</span>
    <span class="list-label">Decorative Presets (Present In Tags, Testing Version)</span>
    <button class="icon-button trailing-icon-button" data-toggled="off">
        <span class="material-symbols-rounded">toggle_off</span>
    </button>
</a>

<!-- END ADDED -->
<div class="menu-divider"></div>

						
						<a href="https://bsky.app/profile/niancookiepanda.bsky.social" class="list-item">
						<span class="material-symbols-rounded leading-icon">satellite_alt</span>
						<span class="list-label">BSKY Profile</span>
						</a>
						<div class="menu-divider"></div>
						<a href="#" class="list-item" id="about-button">
						<span class="material-symbols-rounded leading-icon">info</span>
						<span class="list-label">About Wanxian</span>
						</a>
					</div>
				</div>
			
		</header>
		<div class="about-dialog-backdrop" id="about-dialog-backdrop">
    <div class="about-dialog">
        <div class="dialog-header">
            <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary);">info</span>
            <h2>About Wanxian</h2>
        </div>
        
        <p>Wanxian is a simple and focused tool designed to help you create custom Minecraft Bedrock Edition biome JSON files with ease.</p>
        
        <p>It includes smart layout behavior, a smooth interface, and a system-aware dark theme to make editing more comfortable.</p>
        
        <p>The tool is built to keep everything clear and organized, offering quick access to biome parameters and real-time previews.</p>
        
        <hr style="border: none; border-top: 1px solid var(--md-sys-color-outline-variant); margin: 16px 0;">
        
        <p><strong>Feedback & More:</strong> If you notice issues or want to suggest improvements, you can share your thoughts directly at <a href="https://bsky.app/profile/niancookiepanda.bsky.social" style="color: var(--md-sys-color-primary);">Bluesky profile</a>.</p>
        
        <div class="dialog-actions">
            <button class="m3-text-button" id="close-about-button">Close</button>
        </div>
    </div>
</div>
		<div class="container">
			<!-- File and Form Management is no longer here-->
			<div class="tool-container" style="margin-top: 10px; margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px;">
				<input type="file" id="importJsonFile" accept=".json" style="display: none;">
				<button type="button" class="button add-button " id="importJsonButton">
				<span class="material-symbols-rounded">upload_file</span>
				Import JSON
				</button>
				<button type="button" class="button add-button" id="refreshButton">
				<span class="material-symbols-rounded">refresh</span>
				Reset Form
				</button>
			</div>
			<!-- Preset Management Section -->
			
			<form id="biomeForm">
				<!-- Core Biome Information -->
				<div class="form-group">
					<label for="format_version" class="required-field">Format Version:</label>
					<input type="text" id="format_version" value="1.26.0" required="">
					<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
						<span class="tooltiptext">Version of the JSON schema used by this file. Example: "1.21.120"</span>
					</div>
				</div>
				<div class="form-group">
					<label for="identifier" class="required-field">Biome Identifier:</label>
					<input type="text" id="identifier" placeholder="e.g., mypack:my_custom_biome" required="" value="wanxian:custom_land">
					<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
						<span class="tooltiptext">The namespaced name of your biome (e.g., "mypack:my_custom_biome"). Should only be lowercase and unique.</span>
					</div>
					<div id="validation" class="error" style="color: var(--md-sys-color-error); display:none; margin-top: 10px;"></div>
				</div>
				
				<h2>Biome Components</h2>
				<p>Select the components you wish to include in your biome definition.
				</p>
				<div class="switch-container">
					<label for="enable_clientbiomes">Client Biome:</label>
					<label class="switch">
					<input type="checkbox" id="enable_clientbiomes">
					<span class="slider"></span>
					</label>
				</div>
				<div class="switch-container">
    <label for="show_unused_components">Unused/Legacy Components:</label>
    <label class="switch">
        <input type="checkbox" id="show_unused_components">
        <span class="slider"></span>
    </label>
</div>

<div class="component-section single">
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px;">
        <h3 style="margin: 0; font-size: 1rem; color: var(--md-sys-color-primary);">Biome Preview</h3>
        <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary); opacity: 0.7;">landscape</span>
    </div>
    
    <div id="biome-visualizer" class="mc-scene-container">
        <div class="mc-layer mc-sky"></div>
        <div class="mc-layer mc-sun"></div>
        <div class="mc-layer mc-cloud" style="top: 20px; left: 10%; width: 60px;"></div>
        <div class="mc-layer mc-cloud" style="top: 35px; left: 70%; width: 45px;"></div>
        
        <div class="mc-layer mc-hill-bg"></div>
        
        <div class="mc-layer mc-ground">
            <div class="mc-grass-surface"></div>
        </div>
        
        <div class="mc-layer mc-water-puddle"></div>
        
        <div class="mc-layer mc-tree" style="left: 15%; bottom: 35px;">
            <div class="mc-leaves"></div>
            <div class="mc-trunk"></div>
        </div>
        <div class="mc-layer mc-tree" style="left: 80%; bottom: 45px; transform: scale(0.85);">
            <div class="mc-leaves"></div>
            <div class="mc-trunk"></div>
        </div>
    </div>
</div>
				<div class="menu-divider"></div>
				<!-- Group 1: Climate & Environmental Properties -->
				
				<!-- Component: minecraft:climate -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="climate-content">
						<span class="component-title">climate</span>
						<label class="switch">
						<input type="checkbox" id="enable_climate" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="climate-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Describes temperature, humidity, precipitation, and similar. Biomes without this component will have default values.</p>
							<div class="form-group">
								<label for="climate_temperature">Temperature (Float):</label>
								<input type="number" step="0.01" id="climate_temperature" placeholder="e.g., 0.3">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Temperature affects a variety of visual and behavioral things, including snow and ice placement, sponge drying, and sky color.</span>
								</div>
							</div>
							<div class="form-group">
								<label>Snow Accumulation (Min, Max - Array of 2 Floats):</label>
								<input type="number" step="0.001" id="climate_snow_acc_min" placeholder="e.g., 0.125">
								<input type="number" step="0.001" id="climate_snow_acc_max" placeholder="e.g., 0.25">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Minimum and maximum snow level, each multiple of 0.125 is another snow layer.</span>
								</div>
							</div>
							<div class="form-group">
								<label for="climate_downfall">Downfall (Float):</label>
								<input type="number" step="0.01" id="climate_downfall" placeholder="e.g., 0.2">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Amount that precipitation affects colors and block changes.</span>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:humidity -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="humidity-content">
						<span class="component-title">humidity</span>
						<label class="switch">
						<input type="checkbox" id="enable_humidity" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span> 
					</h3>
					<div id="humidity-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Forces a biome to either always be humid or never humid. Humidity affects the spread chance, and spread rate of fire in the biome.</p>
							<div class="switch-container">
								<label for="humidity_is_humid" class="required-field">Is Humid:</label>
								<label class="switch">
								<input type="checkbox" id="humidity_is_humid">
								<span class="slider"></span> 
								</label>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:partially_frozen -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="partially_frozen-content">
						<span class="component-title">partially frozen</span>
						<label class="switch">
						<input type="checkbox" id="enable_partially_frozen" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>  
					</h3>
					<div id="partially_frozen-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Component will impact the temperature in a frozen biome, causing some areas to not be frozen. Ex: patchy ice, patchy snow.</p>
							<p>This component has no configurable fields, just its presence matters.</p>
						</div>
					</div>
				</div>
				<!-- Group 3: Terrain Generation Rules -->
				<!-- Component: minecraft:multinoise_generation_rules no longer present here-->
				<!-- Group 4: Surface & Material Definitions -->
				
				<!-- Component: minecraft:surface_builder -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="surface_builder-content">
						<span class="component-title">surface builder</span>
						<label class="switch">
						<input type="checkbox" id="enable_surface_builder" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="surface_builder-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Controls the materials used for terrain generation.</p>
							<div class="form-group">
								<label for="surface_builder_type_select" class="required-field">Builder Type:</label>
								<select id="surface_builder_type_select">
									<option value="">--Select Builder Type--</option>
									<option value="minecraft:overworld">minecraft:overworld</option>
									<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
									<option value="minecraft:mesa">minecraft:mesa</option>
									<option value="minecraft:swamp">minecraft:swamp</option>
									<option value="minecraft:capped">minecraft:capped</option>
									<option value="minecraft:the_end">minecraft:the_end</option>
								</select>
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Controls the type of surface builder to use.</span>
								</div>
							</div>
							<!-- Dynamic builder fields will be loaded here based on selection -->
							<div id="surface_builder_dynamic_fields"></div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:mountain_parameters -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="mountain_parameters-content">
						<span class="component-title">mountain parameters</span>
						<label class="switch">
						<input type="checkbox" id="enable_mountain_parameters" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="mountain_parameters-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Noise parameters used to drive mountain terrain generation in Overworld.</p>
							<h4>Top Slide Settings</h4>
							<div class="sub-group">
								<div class="switch-container">
									<label for="top_slide_enabled" class="required-field">Enabled:</label>
									<label class="switch">
									<input type="checkbox" id="top_slide_enabled">
									<span class="slider"></span>          </label>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">If false, top slide will be disabled. If true, other parameters will be taken into account.</span>
									</div>
								</div>
							</div>
							<div class="optional-input-container">
								<div class="switch-container">
									<label for="enable_steep_material_adjustment">Enable Steep Material Adjustment (Optional):</label>
									<label class="switch">
									<input type="checkbox" id="enable_steep_material_adjustment" class="optional-input-toggle">
									<span class="slider"></span>         </label>
								</div>
								<div id="steep_material_adjustment_group" class="optional-input-content" style="display: none;">
									<h4>Steep Material Adjustment Settings</h4>
									<div class="sub-group">
										<div class="form-group" id="steep_material_container">
											<div class="form-group">
												<label for="steep_material_name">Steep Material (Block Specifier):</label>
												<input type="text" id="steep_material_name" placeholder="e.g., minecraft:dirt" value="">
												<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
													<span class="tooltiptext">Name of the block. Example: "minecraft:stone"</span>
												</div>
											</div>
											<div class="optional-input-container">
												<div class="switch-container">
													<label for="toggle_steep_material_states">Enable States (Optional):</label>
													<label class="switch">
													<input type="checkbox" id="toggle_steep_material_states" class="optional-input-toggle">
													<span class="slider"></span>       
													</label>
												</div>
												<div id="steep_material_states_group" class="optional-input-content" style="display: none;">
													<div class="form-group">
														<label for="steep_material_states">Block States (JSON Object):</label>
														<textarea id="steep_material_states" rows="2" placeholder="{&quot;state_name&quot;: &quot;value&quot;}"></textarea>
														<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
															<span class="tooltiptext">Contains members named after each state, with boolean, integer, or string values. Example: {"direction": "north"}</span>
														</div>
													</div>
												</div>
											</div>
										</div>
										<div class="switch-container">
											<label for="steep_north_slopes">North Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_north_slopes">
											<span class="slider"></span>    
											</label>
										</div>
										<div class="switch-container">
											<label for="steep_south_slopes">South Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_south_slopes">
											<span class="slider"></span>                  </label>
										</div>
										<div class="switch-container">
											<label for="steep_east_slopes">East Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_east_slopes">
											<span class="slider"></span>  
											</label>
										</div>
										<div class="switch-container">
											<label for="steep_west_slopes">West Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_west_slopes">
											<span class="slider"></span>    
											</label>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:surface_material_adjustments -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="surface_material_adjustments-content">
						<span class="component-title">surface adjustments</span>
						<label class="switch">
						<input type="checkbox" id="enable_surface_material_adjustments" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="surface_material_adjustments-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Specify fine-detail changes to blocks used in terrain generation (based on a noise function).</p>
							<div id="material_adjustments_container">
								<h4>Adjustments (List of Surface Adjustment Settings)</h4>
								<button type="button" class="button add-button" id="add_material_adjustment">
								<span class="material-symbols-rounded">add</span>
								Add Material Adjustment
								</button>
							</div>
						</div>
					</div>
				</div>
				<!-- Group 5: Biome Transformations & Replacements -->
				<!-- Component: minecraft:overworld_generation_rules is no longer here -->
				<!-- Component: minecraft:replace_biomes -->
				
				<div class="component-section single">
					<h3 class="collapsible-header collapsed" data-target="replace_biomes-content">
						<span class="component-title">replace biomes</span>
						<label class="switch">
						<input type="checkbox" id="enable_replace_biomes" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="replace_biomes-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
						    <h4 style="color: var(--md-sys-color-outline-variant)" class="dialog-header"><span class="material-symbols-rounded">info</span> Needed to generate custom biomes.</h4>
							<p>Replaces a specified portion of one or more Minecraft biomes. Can define multiple replacement rules.</p>
							<p>
						        <code>Don't mention same biome names in multiple replacement rules targeted biomes field!</code>
						    </p>
							<div id="replacements_list_container">
								<h4>Replacements</h4>
							</div>
							<button type="button" class="button add-button" id="add_replacement_button" style="margin-top: 10px;">
							<span class="material-symbols-rounded">add</span>
							Add Replacement
							</button>
						</div>
					</div>
				</div>
				<!-- Group 6: Tags & Spawning -->
				<!-- Component: minecraft:tags -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="tags-content">
						<span class="component-title">tags & presets</span>
						<label class="switch">
						<input type="checkbox" id="enable_tags" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="tags-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Attach arbitrary string tags to this biome.</p>
							<div class="form-group">
								<label for="biome_tags_select">Predefined Tags (Multi-select):</label>
								<select id="biome_tags_select" multiple="" size="8">
									<option value="animal">animal</option>
									<option value="ash">ash</option>
									<option value="bamboo">bamboo</option>
									<option value="basalt_deltas">basalt_deltas</option>
									<option value="beach">beach</option>
									<option value="bee_habitat">bee_habitat</option>
									<option value="birch">birch</option>
									<option value="caves">caves</option>
									<option value="cherry_grove">cherry_grove</option>
									<option value="cold">cold</option>
									<option value="crimson_forest">crimson_forest</option>
									<option value="deep">deep</option>
									<option value="deep_dark">deep_dark</option>
									<option value="desert">desert</option>
									<option value="dripstone_caves">dripstone_caves</option>
									<option value="edge">edge</option>
									<option value="extreme_hills">extreme_hills</option>
									<option value="flower_forest">flower_forest</option>
									<option value="forest">forest</option>
									<option value="forest_generation">forest_generation</option>
									<option value="frozen">frozen</option>
									<option value="frozen_peaks">frozen_peaks</option>
									<option value="grove">grove</option>
									<option value="has_structure_trail_ruins">has_structure_trail_ruins</option>
									<option value="hills">hills</option>
									<option value="ice">ice</option>
									<option value="ice_plains">ice_plains</option>
									<option value="jagged_peaks">jagged_peaks</option>
									<option value="jungle">jungle</option>
									<option value="lukewarm">lukewarm</option>
									<option value="lush_caves">lush_caves</option>
									<option value="mangrove_swamp">mangrove_swamp</option>
									<option value="meadow">meadow</option>
									<option value="mega">mega</option>
									<option value="mesa">mesa</option>
									<option value="monster">monster</option>
									<option value="mooshroom_island">mooshroom_island</option>
									<option value="mountain">mountain</option>
									<option value="mountains">mountains</option>
									<option value="mutated">mutated</option>
									<option value="nether">nether</option>
									<option value="nether_wastes">nether_wastes</option>
									<option value="netherwart_forest">netherwart_forest</option>
									<option value="no_legacy_worldgen">no_legacy_worldgen</option>
									<option value="ocean">ocean</option>
									<option value="overworld">overworld</option>
									<option value="overworld_generation">overworld_generation</option>
									<option value="pale_garden">pale_garden</option>
									<option value="plains">plains</option>
									<option value="plateau">plateau</option>
									<option value="rare">rare</option>
									<option value="river">river</option>
									<option value="roofed">roofed</option>
									<option value="savanna">savanna</option>
									<option value="shore">shore</option>
									<option value="snowy_slopes">snowy_slopes</option>
									<option value="soulsand_valley">soulsand_valley</option>
									<option value="spawn_endermen">spawn_endermen</option>
									<option value="spawn_few_piglins">spawn_few_piglins</option>
									<option value="spawn_few_zombified_piglins">spawn_few_zombified_piglins</option>
									<option value="spawn_ghast">spawn_ghast</option>
									<option value="spawn_magma_cubes">spawn_magma_cubes</option>
									<option value="spawn_many_magma_cubes">spawn_many_magma_cubes</option>
									<option value="spawn_piglin">spawn_piglin</option>
									<option value="spawn_zombified_piglin">spawn_zombified_piglin</option>
									<option value="stone">stone</option>
									<option value="stony_peaks">stony_peaks</option>
									<option value="swamp">swamp</option>
									<option value="taiga">taiga</option>
									<option value="the_end">the_end</option>
									<option value="underwater">underwater</option>
									<option value="warm">warm</option>
									<option value="warped_forest">warped_forest</option>
								</select>
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Select tags from a predefined list.</span>
								</div>
							</div>
							<div class="form-group">
								<label for="custom_tag_input">Custom Tag Name:</label>
								<input type="text" id="custom_tag_input" placeholder="e.g., my_custom_tag">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Enter your own custom tag. Tags should be lowercase and can contain alphanumeric characters, periods, and underscores.</span>
								</div>
								<button type="button" class="button add-button" id="add_custom_tag_button">
								<span class="material-symbols-rounded">add</span>
								Add Custom Tag
								</button>
							</div>
							<div id="custom_tags_display" class="tag-list"></div>
						</div>
						
						
						<div id="decoration-presets-section" class="component-section single" style="display: none; margin-bottom: 20px; border: 1px solid var(--md-sys-color-primary);">
    <div style="padding: 16px; display: flex; align-items: center; justify-content: space-between; background: var(--md-sys-color-surface-container-low); border-radius: var(--radius-m);">
        <div style="display: flex; align-items: center; gap: 15px;">
            <div style="width: 40px; height: 40px; flex-shrink: 0; background: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                <span class="material-symbols-rounded">forest</span>
            </div>
            <div>
                <h3 style="margin: 0; font-size: 1rem; color: var(--md-sys-color-on-surface);">Decorative Presets</h3>
                <p id="decoration-active-count" style="margin: 0; font-size: 0.85rem; color: var(--md-sys-color-on-surface-variant);">0 items selected</p>
            </div>
        </div>
        <button type="button" id="btn_manage_decorations" class="m3-btn-filled button" style="height: 36px; padding: 0 16px;">
            <span class="material-symbols-rounded" style="font-size: 18px; margin-right: 8px;">tune</span>
            Manage
        </button>
    </div>
</div>
					</div>
				
				</div>
				<!-- Component: minecraft:creature_spawn_probability -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="creature_spawn_probability-content">
						<span class="component-title">creature probability</span>
						<label class="switch">
						<input type="checkbox" id="enable_creature_spawn_probability" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span> 
					</h3>
					<div id="creature_spawn_probability-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Probability that creatures will spawn within the biome when a chunk is generated.</p>
							<div class="form-group">
								<label for="creature_spawn_probability_value">Probability (Float):</label>
								<input type="number" step="0.01" min="0.0" max="0.75" id="creature_spawn_probability_value" placeholder="e.g., 0.5" style="display:none;">
<div class="custom-slider-replacement" data-target-id="creature_spawn_probability_value" data-min-value="0.0" data-max-value="0.75" data-decimal-places="2" data-initial-value="0.5"></div>

								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Probabiltity between [0.0, 0.75] of creatures spawning within the biome on chunk generation.</span>
								</div>
							</div>
						</div>
					</div>
				</div>

<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="village_type-content">
						<span class="component-title">village type</span>
						<label class="switch">
						<input type="checkbox" id="enable_village_type" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span> 
					</h3>
					<div id="village_type-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Determines the type of village structure that can spawn in this biome.</p>
							<div class="form-group">
								<label for="village_type_select">Village Type:</label>
								<select id="village_type_select">
									<option value="desert">"desert"</option>
									<option value="ice">"ice"</option>
									<option value="savanna">"savanna"</option>
									<option value="taiga">"taiga"</option>
									<option value="default" selected>Default ("default")</option>
								</select>
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">The style of village buildings that will generate in the biome.</span>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Group 2: Visual Properties -->
				<!-- Component: minecraft:map_tints -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="map_tints-content">
						<span class="component-title">map tints</span>
						<label class="switch">
						<input type="checkbox" id="enable_map_tints" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="map_tints-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Sets the color grass and foliage will be tinted by in this biome on the map.</p>
							<div class="optional-input-container">
								<div class="switch-container">
									<label for="enable_map_tints_foliage">Enable Foliage Tint Color (Optional):</label>
									<label class="switch">
									<input type="checkbox" id="enable_map_tints_foliage" class="optional-input-toggle">
									<span class="slider"></span> </label>
								</div>
								<div id="map_tints_foliage_group" class="optional-input-content" style="display: none;">
									<div class="form-group">
										<label for="map_tints_foliage_color_input">Foliage Tint Color:</label>
										<div class="color-input-group">
											<input type="text" id="map_tints_foliage_color_input" class="color-input-text" placeholder="#RRGGBB or rgb(R,G,B)" value="#6A7039">
											<input type="color" id="map_tints_foliage_color_picker" class="color-input-picker" value="#6A7039">
										</div>
										<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
											<span class="tooltiptext">Sets the color foliage will be tinted by in this biome on the map. Enter as #RRGGBB or rgb(R,G,B).</span>
										</div>
									</div>
								</div>
							</div>
							<h4>Grass Tint Settings (<span class="required-field">Required</span>)</h4>
							<div class="sub-group">
								<div class="radio-group">
									<label class="radio-container">Noise Based Tint
									<input type="radio" name="grass_tint_type" value="noise" id="grass_tint_type_noise" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Custom Tint Color
									<input type="radio" name="grass_tint_type" value="tint" id="grass_tint_type_custom">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div class="form-group" id="grass_custom_tint_group" style="display: none;">
									<label for="grass_custom_tint_color_input" class="required-field">Grass Custom Tint Color:</label>
									<div class="color-input-group">
										<input type="text" id="grass_custom_tint_color_input" class="color-input-text" placeholder="#RRGGBB or rgb(R,G,B)" value="#B6DB61">
										<input type="color" id="grass_custom_tint_color_picker" class="color-input-picker" value="#B6DB61">
									</div>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Tint color used in this biome on the map when 'Custom Tint Color' is selected. Enter as #RRGGBB or rgb(R,G,B).</span>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				
								<!-- Group 7: Unused Components for custom biomes, should be not included-->
								

<div id="unused_components_wrapper" style="display: none;">
    								
				
				
				<!-- Component: minecraft:overworld_height -->
				
				<div class="component-section start invalid">
				    <h3 class="collapsible-header collapsed" data-target="overworld_height-content">
				        <span class="component-title">overworld height</span>
				        <label class="switch">
				            <input type="checkbox" id="enable_overworld_height" class="component-toggle">
				        </label>
				        <span class="material-symbols-rounded"></span>
				    </h3>
				    <div id="overworld_height-content" class="component-content" style="display: none;">
				        <div class="menu-divider"></div>
				        <div style="margin: 25px;">
				            <h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> This is a pre-Caves and Cliffs component. It does not change overworld height, and currently only affects map item rendering.</h4>
				            <p>Controls how this biome is instantiated (and then potentially modified) during world generation of the nether.</p>
				            <p>Noise parameters used to drive terrain height in the Overworld.</p>
				            <div class="radio-group">
				                <label class="radio-container">Noise Type
				                    <input type="radio" name="height_config_type" value="noise_type" id="height_noise_type_radio">
				                    <span class="radio-checkmark"></span>
				                </label>
				                <label class="radio-container">Noise Parameters
				                    <input type="radio" name="height_config_type" value="noise_params" id="height_noise_params_radio">
				                    <span class="radio-checkmark"></span>
				                </label>
				            </div>
				            <div id="height_noise_type_group" class="sub-group" style="display: none;">
				                <label for="noise_type_select" class="required-field">Noise Type (String):</label>
				                <select id="noise_type_select">
				                    <option value="">--Select Noise Type--</option>
				                    <option value="default">default</option>
				                    <option value="default_mutated">default_mutated</option>
				                    <option value="river">river</option>
				                    <option value="deep_ocean">deep_ocean</option>
				                    <option value="lowlands">lowlands</option>
				                    <option value="taiga">taiga</option>
				                    <option value="mountains">mountains</option>
				                    <option value="highlands">highlands</option>
				                    <option value="extreme">extreme</option>
				                    <option value="less_extreme">less_extreme</option>
				                    <option value="beach">beach</option>
				                    <option value="stone_beach">stone_beach</option>
				                    <option value="mushroom">mushroom</option>
				                    <option value="swamp">swamp</option>
				                </select>
				                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
				                    <span class="tooltiptext">Specifies a preset based on a built-in setting rather than manually using noise_params.</span>
				                </div>
				            </div>
				            <div id="height_noise_params_group" class="sub-group" style="display: none;">
				                <label>Noise Parameters (Depth, Scale - Array of 2 Floats):</label>
				                <input type="number" step="0.01" id="noise_params_depth" placeholder="e.g., 1.8">
				                <input type="number" step="0.01" id="noise_params_scale" placeholder="e.g., 0.8">
				                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
				                    <span class="tooltiptext">First value is depth - more negative means deeper underwater, while more positive means higher. Second value is scale, which affects how much noise changes as it moves from the surface.</span>
				                </div>
				            </div>
				        </div>
				    </div>
				</div>
				<!-- Component: minecraft:overworld_generation_rules -->
				<div class="component-section invalid">
					<h3 class="collapsible-header collapsed" data-target="overworld_generation_rules-content">
						<span class="component-title">overworld generation</span>
						<label class="switch">
						<input type="checkbox" id="enable_overworld_generation_rules" class="component-toggle">
						</label>
						<span class="material-symbols-rounded"></span>
					</h3>
					<div id="overworld_generation_rules-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> Pre Caves & Cliffs update component unused for custom biomes.</h4>
							<p>Controls how this biome is instantiated (and then potentially modified) during world generation of the overworld.</p>
							<h4>Generate For Climates</h4>
							<div class="sub-group" id="generate_for_climates_container">
								<p>An array of weighted climate categories.</p>
								<button type="button" class="button add-button" id="add_climate_category">
								<span class="material-symbols-rounded">add</span>
								Add Climate Category
								</button>
							</div>
							<!-- Hills Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Hills Transformation</h4>
								<p>What biome(s) to switch to when converting to a hilly biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="hills_transform_type" value="simple" id="hills_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="hills_transform_type" value="weighted" id="hills_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="hills_transformation_simple_group" class="form-group" style="display: block;">
									<label for="hills_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="hills_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
				  <option value="minecraft:warped_forest">minecraft:warped_forest</option>
				  <option value="minecraft:the_end">minecraft:the_end</option>
				  <option value="minecraft:soulsand_valley">minecraft:soulsand_valley</option>
				  <option value="minecraft:crimson_forest">minecraft:crimson_forest</option>
				  <option value="minecraft:hell">minecraft:hell</option>
				  <option value="minecraft:basalt_deltas">minecraft:basalt_deltas</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="hills_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_hills_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="hills_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- Mutate Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Mutate Transformation</h4>
								<p>What biome(s) to switch to when converting to a mutated biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="mutate_transform_type" value="simple" id="mutate_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="mutate_transform_type" value="weighted" id="mutate_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="mutate_transformation_simple_group" class="form-group" style="display: block;">
									<label for="mutate_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="mutate_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
				  <option value="minecraft:warped_forest">minecraft:warped_forest</option>
				  <option value="minecraft:the_end">minecraft:the_end</option>
				  <option value="minecraft:soulsand_valley">minecraft:soulsand_valley</option>
				  <option value="minecraft:crimson_forest">minecraft:crimson_forest</option>
				  <option value="minecraft:hell">minecraft:hell</option>
				  <option value="minecraft:basalt_deltas">minecraft:basalt_deltas</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="mutate_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_mutate_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="mutate_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- River Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>River Transformation</h4>
								<p>What biome(s) to switch to when converting to a river biome (if not the Vanilla 'river' biome).</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="river_transform_type" value="simple" id="river_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="river_transform_type" value="weighted" id="river_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="river_transformation_simple_group" class="form-group" style="display: block;">
									<label for="river_transformation_select" class="required-field">Biome Names (Multi-select):</label>
								
								<select id="river_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
				  <option value="minecraft:warped_forest">minecraft:warped_forest</option>
                  <option value="minecraft:the_end">minecraft:the_end</option>
                  <option value="minecraft:soulsand_valley">minecraft:soulsand_valley</option>
                  <option value="minecraft:crimson_forest">minecraft:crimson_forest</option>
                  <option value="minecraft:hell">minecraft:hell</option>
                  <option value="minecraft:basalt_deltas">minecraft:basalt_deltas</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="river_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_river_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="river_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- Shore Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Shore Transformation</h4>
								<p>What biome(s) to switch to when adjacent to an ocean biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="shore_transform_type" value="simple" id="shore_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="shore_transform_type" value="weighted" id="shore_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="shore_transformation_simple_group" class="form-group" style="display: block;">
									<label for="shore_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="shore_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
				  <option value="minecraft:warped_forest">minecraft:warped_forest</option>
<option value="minecraft:the_end">minecraft:the_end</option>
<option value="minecraft:soulsand_valley">minecraft:soulsand_valley</option>
<option value="minecraft:crimson_forest">minecraft:crimson_forest</option>
<option value="minecraft:hell">minecraft:hell</option>
<option value="minecraft:basalt_deltas">minecraft:basalt_deltas</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="shore_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_shore_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="shore_weighted_biomes_container"></div>
								</div>
							</div>
						</div>
					</div>
				</div>	
				<!-- Component: minecraft:multinoise_generation_rules -->
				<div class="component-section end invalid">
				    <h3 class="collapsible-header collapsed" data-target="multinoise_generation_rules-content">
				        <span class="component-title">multinoise generation</span>
				        <label class="switch">
				            <input type="checkbox" id="enable_multinoise_generation_rules" class="component-toggle">
				        </label>
				        <span class="material-symbols-rounded"></span>
				    </h3>
				    <div id="multinoise_generation_rules-content" class="component-content" style="display: none;">
				        <div class="menu-divider"></div>
				        <div style="margin: 25px;">
				            <h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> Pre Caves & Cliffs update component unused for custom biomes.</h4>
				            <p>Controls how this biome is instantiated (and then potentially modified) during world generation of the nether.</p>
				            <div class="form-group">
				                <label for="multinoise_target_altitude">Target Altitude (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_altitude" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_humidity">Target Humidity (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_humidity" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_temperature">Target Temperature (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_temperature" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_weirdness">Target Weirdness (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_weirdness" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_weight">Weight (Float):</label>
				                <input type="number" step="0.01" id="multinoise_weight" placeholder="e.g., 1.0">
				            </div>
				        </div>
				    </div>
				</div></div>
			</form>
			<div id="hidden-container">
			    <div class="menu-divider"></div>
				<form id="clientBiomeForm">
					
					
					<div class="component-section start">
						<h3 class="collapsible-header collapsed" data-target="sky_color-content">
							<span class="component-title">sky_color</span>
							<label class="switch">
							<input type="checkbox" id="comp_sky_color" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="sky_color-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Sky color (hex)</label>
									<div class="color-input-group">
										<input type="text" id="sky_color_hex_text" class="color-input-text" value="#88AAFF" placeholder="#RRGGBB">
										<input type="color" id="sky_color_hex" class="color-input-picker" value="#88aaff">
									</div>
								</div>
								<div class="form-group">
									<label>Or RGB array</label>
									<input id="sky_color_arr" type="text" placeholder="[136,170,255]">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="water_appearance-content">
							<span class="component-title">water_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_water_appearance" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="water_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Surface color</label>
									<div class="color-input-group">
										<input type="text" id="water_surface_color_text" class="color-input-text" value="#4455FF" placeholder="#RRGGBB">
										<input type="color" id="water_surface_color" class="color-input-picker" value="#4455ff">
									</div>
								</div>
								<div class="form-group">
									<label>Surface opacity (0.0–1.0)</label>
									<input id="water_surface_opacity" type="number" min="0" max="1" step="0.01" value="1.0" style="display:none;">
<div class="custom-slider-replacement" data-target-id="water_surface_opacity" data-min-value="0.0" data-max-value="1.0" data-decimal-places="2" data-initial-value="1.0"></div>


								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="fog_appearance-content">
							<span class="component-title">fog_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_fog" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="fog_appearance-content" class="component-content">
    <div class="menu-divider"></div>
    <div style="margin: 25px;">
        <div class="form-group">
            <label>Fog Identifier</label>
            <div style="display: flex; gap: 8px; align-items: center;">
                <input id="fog_identifier" type="text" placeholder="namespace:fog_name" style="flex-grow: 1; margin-bottom: 0;">
                
                <button type="button" class="m3-icon-btn-small" id="btn_import_fog_file" title="Import Fog JSON File">
                    <span class="material-symbols-rounded">file_open</span>
                </button>
                <input type="file" id="fog_file_input" accept=".json" style="display: none;">

                <button type="button" class="m3-icon-btn-small" id="btn_open_fog_creator" title="Create/Edit Custom Fog">
                    <span class="material-symbols-rounded">edit_square</span>
                </button>
            </div>
            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
                <span class="tooltiptext">The namespaced identifier for the fog. Use the buttons to import or create a definition.</span>
            </div>
        </div>
    </div>
</div>

					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="foliage_appearance-content">
							<span class="component-title">foliage_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_foliage" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="foliage_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Use color picker</label>
									<div class="color-input-group">
										<input type="text" id="foliage_color_hex_text" class="color-input-text" value="#55AA33" placeholder="#RRGGBB">
										<input type="color" id="foliage_color_hex" class="color-input-picker" value="#55aa33">
									</div>
								</div>
								<div class="form-group">
									<label>Or color map</label>
									<select id="foliage_color_map">
										<option value="">-- none --</option>
										<option value="foliage">foliage</option>
										<option value="birch">birch</option>
										<option value="evergreen">evergreen</option>
										<option value="mangrove_swamp_foliage">mangrove_swamp_foliage</option>
										<option value="swamp_foliage">swamp_foliage</option>
										<option value="dry_foliage">dry_foliage</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="grass_appearance-content">
							<span class="component-title">grass_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_grass" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="grass_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Use color picker</label>
									<div class="color-input-group">
										<input type="text" id="grass_color_hex_text" class="color-input-text" value="#77CC44" placeholder="#RRGGBB">
										<input type="color" id="grass_color_hex" class="color-input-picker" value="#77cc44">
									</div>
								</div>
								<div class="form-group">
									<label>Or color map</label>
									<select id="grass_color_map">
										<option value="">-- none --</option>
										<option value="grass">grass</option>
										<option value="swamp_grass">swamp_grass</option>
									</select>
								</div>
								<div class="switch-container">
									<label for="grass_is_shaded">grass_is_shaded (adds roof-like shading)</label>
									<label class="switch">
									<input type="checkbox" id="grass_is_shaded">
									<span class="slider"></span>
									</label>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section end">
						<h3 class="collapsible-header collapsed" data-target="dry_foliage_color-content">
							<span class="component-title">dry_foliage_color</span>
							<label class="switch">
							<input type="checkbox" id="comp_dry_foliage" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="dry_foliage_color-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Dry foliage color (picker)</label>
									<div class="color-input-group">
										<input type="text" id="dry_foliage_hex_text" class="color-input-text" value="#AAAAAA" placeholder="#RRGGBB">
										<input type="color" id="dry_foliage_hex" class="color-input-picker" value="#aaaaaa">
									</div>
								</div>
								<div class="form-group">
									<label>Or RGB array</label>
									<input id="dry_foliage_array" type="text" placeholder="[170,170,170]">
								</div>
							</div>
						</div>
					</div>
					
					
					<div class="component-section single">
						<h3 class="collapsible-header collapsed" data-target="precipitation-content">
							<span class="component-title">precipitation</span>
							<label class="switch">
								<input type="checkbox" id="comp_precip" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="precipitation-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Mode</label>
									<select id="precip_mode">
										<option value="single">Single (recommended)</option>
										<option value="advanced">Advanced (allow multiple)</option>
									</select>
						<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
    <span class="tooltiptext">Don't change it.</span>
</div>		</div>
								<div id="precip_single" class="sub-group">
									<div class="form-group">
										<label>Type</label>
										<select id="precip_type">
											<option value="">-- select --</option>
											<option value="ash">ash</option>
											<option value="blue_spores">blue_spores</option>
											<option value="red_spores">red_spores</option>
											<option value="white_ash">white_ash</option>
										</select>
									</div>
									<div class="form-group">
										<label>Density (float)</label>
										<input id="precip_density" type="number" step="0.01" min="0" placeholder="e.g. 0.5">
									</div>
								</div>
								<div id="precip_advanced" class="sub-group" style="display:none;">
					<h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span>You may face error console logs and it may not appear properly in your world!</h4>				<div class="form-group">
										<label>ash</label>
										<input id="precip_ash" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>blue_spores</label>
										<input id="precip_blue_spores" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>red_spores</label>
										<input id="precip_red_spores" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>white_ash</label>
										<input id="precip_white_ash" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
								</div>
							</div>
						</div>
					</div>
					
<div class="component-section single">
    <h3 class="collapsible-header collapsed" data-target="vibrant_visuals-content">
        <span class="component-title">vibrant visuals</span>
        <label class="switch">
            <input type="checkbox" id="comp_vibrant_visuals" class="component-toggle">
            
        </label>
        <span class="material-symbols-rounded"></span>
    </h3>
    <div id="vibrant_visuals-content" class="component-content">
        <div class="menu-divider"></div>
        <div style="margin: 25px;">
            <p>Define identifiers for vibrant visual components. Leave fields empty to skip specific identifiers.</p>
            
            <div class="form-group">
                <label>Atmosphere Identifier</label>
                <input id="vibrant_atmosphere" type="text" placeholder="namespace:atmosphere_definition">
            </div>

            <div class="form-group">
                <label>Color Grading Identifier</label>
                <input id="vibrant_color_grading" type="text" placeholder="namespace:color_grading">
            </div>

            <div class="form-group">
                <label>Cubemap Identifier</label>
                <input id="vibrant_cubemap" type="text" placeholder="namespace:cubemap_definition">
            </div>

            <div class="form-group">
                <label>Lighting Identifier</label>
                <input id="vibrant_lighting" type="text" placeholder="namespace:lighting_definition">
            </div>

            <div class="form-group">
                <label>Water Identifier</label>
                <input id="vibrant_water" type="text" placeholder="namespace:water_definition">
            </div>
        </div>
    </div>
</div>

					
					<div class="component-section start">
						<h3 class="collapsible-header collapsed" data-target="ambient_sounds-content">
							<span class="component-title">ambient_sounds</span>
							<label class="switch">
							<input type="checkbox" id="comp_ambient" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="ambient_sounds-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Loop sound (named sound reference)</label>
									<input id="ambient_loop" type="text" placeholder="namespace:sound_loop">
								</div>
								<div class="form-group">
									<label>Addition (occasional) – asset</label>
									<input id="ambient_add_asset" type="text" placeholder="namespace:sound_add_asset">
								</div>
								<div class="form-group">
									<label>Addition (occasional) – chance</label>
									<input id="ambient_add_chance" type="number" min="0" max="1" step="0.01" placeholder="chance 0.0–1.0" style="display:none;">
<div class="custom-slider-replacement" data-target-id="ambient_add_chance" data-min-value="0.0" data-max-value="1.0" data-decimal-places="2" data-initial-value="0.0"></div>

								</div>
								<div class="form-group">
									<label>Mood (rare, low-light) reference</label>
									<input id="ambient_mood" type="text" placeholder="namespace:sound_mood">
								</div>
								<div class="menu-divider"></div>
								<div class="switch-container">
									<label for="comp_underwater_ambient">Enable Underwater ambient sounds</label>
									<label class="switch">
									<input type="checkbox" id="comp_underwater_ambient">
									<span class="slider"></span>
									</label>
								</div>
								<div id="underwater_ambient_block" class="sub-group" style="display:none;">
									<div class="form-group">
										<label>Underwater addition (asset)</label>
										<input id="underwater_add_asset" type="text" placeholder="namespace:underwater_add_asset">
									</div>
									<div class="form-group">
										<label>Underwater addition (chance)</label>
										<input id="underwater_add_chance" type="number" min="0" max="1" step="0.01" placeholder="chance 0.0–1.0" style="display:none;">
<div class="custom-slider-replacement" data-target-id="underwater_add_chance" data-min-value="0.0" data-max-value="1.0" data-decimal-places="2" data-initial-value="0.0"></div>

									</div>
									<div class="form-group">
										<label>Underwater loop</label>
										<input id="underwater_loop" type="text" placeholder="namespace:underwater_loop">
									</div>
									<div class="form-group">
										<label>Underwater mood (rare)</label>
										<input id="underwater_mood" type="text" placeholder="namespace:underwater_mood">
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section end">
						<h3 class="collapsible-header collapsed" data-target="biome_music-content">
							<span class="component-title">biome_music</span>
							<label class="switch">
							<input type="checkbox" id="comp_music" class="component-toggle">
							</label>
							<span class="material-symbols-rounded"></span>
						</h3>
						<div id="biome_music-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Music definition (reference)</label>
									<input id="music_definition" type="text" placeholder="namespace:music_definition">
								</div>
								<div class="form-group">
									<label>Volume multiplier (0–1)</label>
									<input id="music_volume" type="number" min="0" max="1" step="0.01" value="1.0" style="display:none;">
<div class="custom-slider-replacement" data-target-id="music_volume" data-min-value="0.0" data-max-value="1.0" data-decimal-places="2" data-initial-value="1.0"></div>


								</div>
								<div class="form-group">
									<label>Enable underwater music?</label>
									<select id="music_underwater">
										<option value="">-- default --</option>
										<option value="true">true</option>
										<option value="false">false</option>
									</select>
								</div>
							</div>
						</div>
					</div>
				</form>
			</div>
		</div>
		<!-- Custom Modal HTML -->
		<div id="modalOverlay" class="modal-overlay" style="display: none;">
			<div class="modal-box">
				<h4 id="modalTitle"></h4>
				<p id="modalContent"></p>
				<input type="text" id="modalInput" class="modal-input" style="display: none;">
				<div class="modal-buttons">
					<button id="modalCancelButton" class="secondary">Cancel</button>
					<button id="modalConfirmButton">Confirm</button>
				</div>
			</div>
		</div>
		<!-- Multi-Export Modal -->
		<div id="multiExportModalOverlay" class="modal-overlay" style="display: none;">
			<div class="modal-box" style="max-width: 500px; text-align: left;">
				<h4>Export Multiple Presets</h4>
				<p>Select the presets you want to include in the .mcpack file.</p>
				<div class="form-group">
					<label for="mcpackNameInput" class="required-field">Pack Name:</label>
					<input type="text" id="mcpackNameInput" class="modal-input" placeholder="e.g., My Awesome Biomes">
				</div>
				<div id="multiExportPresetList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--md-sys-color-outline); border-radius: 8px; padding: 10px; margin-bottom: 20px;">
					<!-- Preset checkboxes will be dynamically inserted here -->
				</div>
				<div class="modal-buttons">
					<button id="multiExportCancelButton" class="secondary">Cancel</button>
					<button id="multiExportConfirmButton">Export .mcpack</button>
				</div>
			</div>
		</div>
		<!-- Snackbar/Toast Bar -->
		<div id="snackbar" class="snackbar">Form values reset!</div>
		<!-- Scroller custom -->
		<div id="fastScrollTrack" class="fast-scroll-track">
    <div id="fastScrollThumb" class="fast-scroll-thumb">
        <span class="material-symbols-rounded">unfold_more</span>
    </div>
</div>

<!-- ADDED: Theme Picker Modal -->
<div id="themeModalOverlay" class="modal-overlay" style="display: none;">
    <div class="modal-box" style="width: 100%; max-width: 600px;">
        <h4>Select Color Theme</h4>
        <p>Choose a color palette to personalize the app.</p>
        
        <div id="themeListContainer" class="theme-grid">
            <!-- Themes will be generated here by JS -->
        </div>

        <div class="modal-buttons">
            <button id="closeThemeModal" class="secondary">Close</button>
        </div>
    </div>
</div>

<div id="fogCreatorModalOverlay" class="modal-overlay" style="display: none;">
    <div class="modal-box" style="width: 95%; max-width: 900px; height: 90vh; display: flex; flex-direction: column; padding: 0;">
        
        <div class="m3-modal-header" style="padding: 20px 24px; border-bottom: 1px solid var(--md-sys-color-outline-variant);">
            <div style="display: flex; align-items: center; gap: 12px;">
                <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary); font-size: 28px;">cloud_circle</span>
                <h3 style="margin: 0; font-size: 1.4rem;">Fog Creator</h3>
            </div>
            <button type="button" id="btn_fog_import_json" class="m3-text-button" style="padding: 0 12px;">
                <span class="material-symbols-rounded" style="font-size: 18px; margin-right: 6px;">upload_file</span>
                Import JSON
            </button>
            <input type="file" id="fog_creator_import_input" accept=".json" style="display: none;">
        </div>

        <div style="display: flex; flex-grow: 1; overflow: hidden;">
            
            <div class="fog-sidebar" style="width: 200px; background: var(--md-sys-color-surface-container-low); border-right: 1px solid var(--md-sys-color-outline-variant); overflow-y: auto; padding: 10px 0;">
                <div class="fog-tab active" data-tab="general">General Info</div>
                <div class="menu-divider"></div>
                <div class="fog-tab-header">Distance Fog</div>
                <div class="fog-tab" data-tab="air">Air</div>
                <div class="fog-tab" data-tab="water">Water</div>
                <div class="fog-tab" data-tab="weather">Weather</div>
                <div class="fog-tab" data-tab="lava">Lava</div>
                <div class="fog-tab" data-tab="lava_resistance">Lava Resistance</div>
                <div class="fog-tab" data-tab="powder_snow">Powder Snow</div>
            </div>

            <div class="fog-form-content" style="flex-grow: 1; padding: 24px; overflow-y: auto;">
                
                <div id="tab_content_general" class="fog-tab-content" style="display: block;">
                    <h4>General Definition</h4>
                    <p style="color: var(--md-sys-color-on-surface-variant); font-size: 0.9em; margin-bottom: 20px;">
                        Basic metadata for your fog file.
                    </p>
                    <div class="form-group">
                        <label class="required-field">Fog Identifier (namespace:name)</label>
                        <input type="text" id="fog_form_id" placeholder="example:my_custom_fog">
                    </div>
                </div>

                <div id="fog_distance_container" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h4 id="fog_dist_title" style="margin: 0; text-transform: capitalize;">Air Fog</h4>
                        
                        <div class="switch-container" style="margin: 0;">
                            <label for="fog_dist_enable" style="margin-right: 10px;">Enable</label>
                            <label class="switch">
                                <input type="checkbox" id="fog_dist_enable">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <div id="fog_dist_fields">
                        <div class="form-group">
                            <label>Fog Color</label>
                            <div class="color-input-group">
                                <input type="text" id="fog_dist_color_text" class="color-input-text" placeholder="#RRGGBB">
                                <input type="color" id="fog_dist_color_picker" class="color-input-picker">
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Fog Start (Distance)</label>
                            <input type="number" id="fog_dist_start" step="0.1" placeholder="e.g. 0.0">
                        </div>

                        <div class="form-group">
                            <label>Fog End (Distance)</label>
                            <input type="number" id="fog_dist_end" step="0.1" placeholder="e.g. 64.0">
                        </div>

                        <div class="form-group">
                            <label>Render Distance Type</label>
                            <select id="fog_dist_type">
                                <option value="render">Render (Dynamic based on user settings)</option>
                                <option value="fixed">Fixed (Blocks)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="fog_dist_disabled_msg" style="display: none; text-align: center; color: var(--md-sys-color-outline); padding: 40px;">
                        <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.5;">visibility_off</span>
                        <p>This fog type is disabled.</p>
                    </div>
                </div>

            </div>
        </div>

        <div class="m3-modal-footer" style="border-top: 1px solid var(--md-sys-color-outline-variant); padding: 16px 24px; display: flex; align-items: center;">
            
            <button id="btn_fog_export_file" class="m3-modal-btn m3-btn-text" style="margin-right: auto; display: flex; align-items: center; gap: 8px;">
                <span class="material-symbols-rounded">download</span> Download JSON
            </button>

            <button id="btn_fog_cancel" class="m3-modal-btn m3-btn-text">Cancel</button>
            <button id="btn_fog_save_memory" class="m3-modal-btn m3-btn-filled">Okay</button>
        </div>
    </div>
</div>

<div id="decorationModalOverlay" class="modal-overlay" style="display: none;">
    <div class="modal-box" style="width: 90%; max-width: 900px; height: 85vh; display: flex; flex-direction: column; padding: 0;">
        
        <div class="m3-modal-header" style="padding: 16px 24px; border-bottom: 1px solid var(--md-sys-color-outline-variant); display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 12px;">
                <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary);">extension</span>
                <h3 style="margin: 0; font-size: 1.3rem;">Decoration Library</h3>
            </div>
            <div class="search-container" style="position: relative; width: 250px;">
                <span class="material-symbols-rounded" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: var(--md-sys-color-outline); font-size: 20px;">search</span>
                <input type="text" id="decoration_search" placeholder="Search items..." style="width: 100%; padding: 8px 8px 8px 36px; border-radius: 20px; border: 1px solid var(--md-sys-color-outline); background: var(--md-sys-color-surface);">
            </div>
        </div>

        <div style="display: flex; flex-grow: 1; overflow: hidden;">
            <div id="decoration_categories" class="fog-sidebar" style="width: 220px; background: var(--md-sys-color-surface-container-low); border-right: 1px solid var(--md-sys-color-outline-variant); overflow-y: auto; padding: 10px 0;">
                </div>

            <div id="decoration_items_container" class="fog-form-content" style="flex-grow: 1; padding: 0; overflow-y: auto; background: var(--md-sys-color-surface);">
                <div id="decoration_empty_state" style="display:none; text-align: center; padding: 50px; color: var(--md-sys-color-outline);">
                    <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.5;">search_off</span>
                    <p>No matching presets found.</p>
                </div>
            </div>
        </div>

        <div class="m3-modal-footer" style="border-top: 1px solid var(--md-sys-color-outline-variant); padding: 12px 24px; display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 0.9rem; color: var(--md-sys-color-primary);">
                <span id="decoration_total_counter" style="font-weight: bold;">0</span> items selected
            </div>
            <button id="btn_close_decorations" class="m3-modal-btn m3-btn-filled">Done</button>
        </div>
    </div>
</div>



<!-- END ADDED -->

		<script src="jszip.min.js" crossorigin="anonymous"></script>
		<script>
			// --- Global Constants & State ---
			const PRESET_STORAGE_KEY = 'bibuild_presets';
			let customTags = [];
			
			// --- Utility & Helper Functions ---
			
			function generateUuidv4() {
			    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
			        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
			        return v.toString(16);
			    });
			}
			
			// Custom Modal Function
			function showModal({ title, message, needsInput = false, onConfirm, onCancel }) {
			    const overlay = document.getElementById('modalOverlay');
			    document.getElementById('modalTitle').textContent = title;
			    document.getElementById('modalContent').textContent = message;
			    
			    const input = document.getElementById('modalInput');
			    input.style.display = needsInput ? 'block' : 'none';
			    input.value = '';
			
			    overlay.style.display = 'flex';
			
			    const confirmButton = document.getElementById('modalConfirmButton');
			    const cancelButton = document.getElementById('modalCancelButton');
			
			    // Clone and replace buttons to remove old event listeners
			    const newConfirmButton = confirmButton.cloneNode(true);
			    const newCancelButton = cancelButton.cloneNode(true);
			    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
			    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
			
			    newConfirmButton.addEventListener('click', () => {
			        overlay.style.display = 'none';
			        if (onConfirm) onConfirm(needsInput ? input.value : true);
			    });
			    newCancelButton.addEventListener('click', () => {
			        overlay.style.display = 'none';
			        if (onCancel) onCancel();
			    });
			    
			    if(needsInput) input.focus();
			}
			
			// Snackbar/Toast Bar Function
			function showSnackbar(message) {
			    const snackbar = document.getElementById('snackbar');
			    snackbar.textContent = message;
			    snackbar.classList.add('show');
			    setTimeout(() => snackbar.classList.remove('show'), 3000);
			}
			
			// --- JSON Generation and Form Population ---
			
			function getJsonFromForm() {
			    return generateFullBiomeJson(); 
			}
			
			function populateFormFromJson(jsonData) {
			    resetForm(); 
			    try {
			        _populateFormFromJson(jsonData); 
			        showSnackbar('Data loaded into form successfully!');
			    } catch (error) {
			        showModal({
			            title: 'Load Error',
			            message: `Failed to load data into form: ${error.message}`,
			            onConfirm: () => {}
			        });
			        console.error("Population Error:", error);
			        resetForm(); 
			    }
			}
			
			
			// --- Preset Management ---
			
			function getPresets() {
			    try {
			        const presets = localStorage.getItem(PRESET_STORAGE_KEY);
			        return presets ? JSON.parse(presets) : {};
			    } catch (e) {
			        console.error("Could not parse presets from localStorage", e);
			        return {};
			    }
			}
			
			function savePresets(presets) {
			    localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
			}
			
			function updatePresetDropdown() {
			    const presets = getPresets();
			    const presetNames = Object.keys(presets).sort();
			    const select = document.getElementById('presetLoadSelect');
			    select.innerHTML = '';
			
			    if (presetNames.length === 0) {
			        select.innerHTML = '<option value="">-- No Presets Found --</option>';
			    } else {
			        presetNames.forEach(name => {
			            const option = document.createElement('option');
			            option.value = name;
			            option.textContent = name;
			            select.appendChild(option);
			        });
			    }
			}
			
			function handleSavePreset() {
    let serverJson, clientJson;

    // 1. Generate Server JSON
    try {
        serverJson = generateFullBiomeJson();
    } catch (error) {
        showModal({
            title: 'Cannot Save Preset',
            message: `Server Biome Error: ${error.message}`,
            onConfirm: () => {}
        });
        return;
    }

    // 2. Generate Client JSON
    try {
        // Re-use the input values and global buildComponents function
        const identifier = document.getElementById('identifier').value.trim().toLowerCase();
        const fv = document.getElementById('format_version').value.trim();
        
        // buildComponents() gathers data from the Client form
        const clientComponents = buildComponents(); 
        
        clientJson = {
            "format_version": fv,
            "minecraft:client_biome": {
                "description": { "identifier": identifier },
                "components": clientComponents
            }
        };
    } catch (error) {
        showModal({
            title: 'Cannot Save Preset',
            message: `Client Biome Error: ${error}`, // buildComponents throws strings, not Error objects
            onConfirm: () => {}
        });
        return;
    }

    // 3. Save Both to LocalStorage
    showModal({
        title: 'Save Preset',
        message: 'Enter a name for your preset:',
        needsInput: true,
        onConfirm: (presetName) => {
            if (!presetName || presetName.trim() === '') {
                showSnackbar('Preset name cannot be empty.');
                return;
            }
            const presets = getPresets();
            
            // Store as a composite object
            presets[presetName.trim()] = {
                server: serverJson,
                client: clientJson
            };
            
            savePresets(presets);
            updatePresetDropdown();
            showSnackbar(`Preset "${presetName.trim()}" saved (Server & Client)!`);
        }
    });
}

			
			function handleLoadPreset() {
    const select = document.getElementById('presetLoadSelect');
    const presetName = select.value;
    if (!presetName) {
        showSnackbar('No preset selected.');
        return;
    }
    const presets = getPresets();
    const presetData = presets[presetName];
    
    if (presetData) {
        // Reset both forms first to ensure a clean slate
        resetForm();
        
        // Check if this is the new Combined format (has 'server' and 'client' keys)
        if (presetData.server && presetData.client) {
            
            // 1. Load Server Data
            try {
                _populateFormFromJson(presetData.server);
                // Update Server Preview
                document.getElementById('jsonOutput').textContent = JSON.stringify(presetData.server, null, 2);
            } catch (e) {
                console.error("Error loading server part of preset", e);
            }

            // 2. Load Client Data
            try {
                if (typeof populateClientForm === 'function') {
                    populateClientForm(presetData.client);
                    // Update Client Preview
                    document.getElementById('outputJson').textContent = JSON.stringify(presetData.client, null, 2);
                }
            } catch (e) {
                console.error("Error loading client part of preset", e);
            }

            showSnackbar(`Preset "${presetName}" loaded (Server & Client)!`);
            
        } else {
            // Fallback for Legacy Presets (Server JSON only)
            try {
                _populateFormFromJson(presetData);
                document.getElementById('jsonOutput').textContent = JSON.stringify(presetData, null, 2);
                showSnackbar(`Legacy preset "${presetName}" loaded (Server Only).`);
            } catch (e) {
                 showModal({
                    title: 'Error',
                    message: `Failed to load legacy preset: ${e.message}`,
                    onConfirm: () => {}
                });
            }
        }
    } else {
         showModal({
            title: 'Error',
            message: `Could not find data for preset "${presetName}".`,
            onConfirm: () => {}
        });
    }
}

			
			function handleDeletePreset() {
			    const select = document.getElementById('presetLoadSelect');
			    const presetName = select.value;
			    if (!presetName) {
			        showSnackbar('No preset selected to delete.');
			        return;
			    }
			
			    showModal({
			        title: 'Delete Preset',
			        message: `Are you sure you want to delete the preset "${presetName}"? This cannot be undone.`,
			        onConfirm: () => {
			            const presets = getPresets();
			            delete presets[presetName];
			            savePresets(presets);
			            updatePresetDropdown();
			            showSnackbar(`Preset "${presetName}" deleted.`);
			        }
			    });
			}
			
			// --- Multi-Export Functionality ---
    function handleExportMultiple() {
    const presets = getPresets();
    const presetNames = Object.keys(presets).sort();
    const presetListContainer = document.getElementById('multiExportPresetList');
    const modalOverlay = document.getElementById('multiExportModalOverlay');
    
    presetListContainer.innerHTML = ''; // Clear previous list

    if (presetNames.length === 0) {
        showSnackbar("No saved presets to export.");
        return;
    }

    // --- ADDED: Select All Option ---
    const selectAllWrapper = document.createElement('div');
    selectAllWrapper.className = 'preset-item-container';
    selectAllWrapper.style.backgroundColor = 'var(--md-sys-color-surface-variant)';
    selectAllWrapper.style.borderRadius = '8px';
    selectAllWrapper.style.marginBottom = '10px';
    
    const selectAllHeader = document.createElement('div');
    selectAllHeader.className = 'preset-header';
    selectAllHeader.style.padding = '10px';

    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.id = 'select_all_presets';
    
    const selectAllLabel = document.createElement('label');
    selectAllLabel.htmlFor = 'select_all_presets';
    selectAllLabel.textContent = "Select All Presets";
    
    selectAllHeader.appendChild(selectAllCheckbox);
    selectAllHeader.appendChild(selectAllLabel);
    selectAllWrapper.appendChild(selectAllHeader);
    presetListContainer.appendChild(selectAllWrapper);
    // --------------------------------

    presetNames.forEach(name => {
        const data = presets[name];
        const hasServer = !!(data.server || data['minecraft:biome']);
        const hasClient = !!(data.client);

        const wrapper = document.createElement('div');
        wrapper.className = 'preset-item-container';

        const header = document.createElement('div');
        header.className = 'preset-header';

        const mainCheckbox = document.createElement('input');
        mainCheckbox.type = 'checkbox';
        mainCheckbox.id = `preset_main_${name}`;
        mainCheckbox.dataset.presetName = name;
        mainCheckbox.checked = false; // CHANGED: Default to unchecked

        const label = document.createElement('label');
        label.htmlFor = `preset_main_${name}`;
        label.textContent = name;

        const expandBtn = document.createElement('button');
        expandBtn.className = 'preset-expand-btn';
        expandBtn.innerHTML = '<span class="material-symbols-rounded">expand_more</span>';
        
        header.appendChild(mainCheckbox);
        header.appendChild(label);
        header.appendChild(expandBtn);

        const details = document.createElement('div');
        details.className = 'preset-details';
        // Initially disable details opacity since main is unchecked
        details.style.opacity = '0.5'; 
        details.style.pointerEvents = 'none';

        if (hasServer) {
            const sDiv = document.createElement('div');
            sDiv.className = 'sub-file-option';
            sDiv.innerHTML = `
                <input type="checkbox" id="sub_server_${name}" checked>
                <label for="sub_server_${name}">Server Biome</label>
                <span class="badge">BP</span>`;
            details.appendChild(sDiv);
        }

        if (hasClient) {
            const cDiv = document.createElement('div');
            cDiv.className = 'sub-file-option';
            cDiv.innerHTML = `
                <input type="checkbox" id="sub_client_${name}" checked>
                <label for="sub_client_${name}">Client Biome</label>
                <span class="badge">RP</span>`;
            details.appendChild(cDiv);
        } else {
            const noClient = document.createElement('div');
            noClient.className = 'sub-file-option';
            noClient.style.opacity = '0.5';
            noClient.innerHTML = `<span class="material-symbols-rounded" style="font-size:16px; margin-right:5px;">block</span> No Client Data`;
            details.appendChild(noClient);
        }

        wrapper.appendChild(header);
        wrapper.appendChild(details);
        presetListContainer.appendChild(wrapper);

        expandBtn.addEventListener('click', (e) => {
            e.preventDefault();
            const isHidden = details.style.display === 'none' || details.style.display === '';
            details.style.display = isHidden ? 'block' : 'none';
            expandBtn.classList.toggle('expanded', isHidden);
        });

        mainCheckbox.addEventListener('change', () => {
            details.style.opacity = mainCheckbox.checked ? '1' : '0.5';
            details.style.pointerEvents = mainCheckbox.checked ? 'auto' : 'none';
            
            // Update "Select All" state if individual clicked
            if (!mainCheckbox.checked) selectAllCheckbox.checked = false;
        });
    });

    // --- ADDED: Select All Logic ---
    selectAllCheckbox.addEventListener('change', () => {
        const allMain = document.querySelectorAll('#multiExportPresetList input[type="checkbox"][id^="preset_main_"]');
        allMain.forEach(cb => {
            cb.checked = selectAllCheckbox.checked;
            cb.dispatchEvent(new Event('change')); // Trigger opacity change logic
        });
    });
    // -------------------------------

    modalOverlay.style.display = 'flex';

    const confirmButton = document.getElementById('multiExportConfirmButton');
    const cancelButton = document.getElementById('multiExportCancelButton');

    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

    newConfirmButton.addEventListener('click', processMultiExport);
    newCancelButton.addEventListener('click', () => {
        modalOverlay.style.display = 'none';
    });
}


			
async function processMultiExport() {
    const packNameInput = document.getElementById('mcpackNameInput');
    const packName = packNameInput.value.trim() || `Wanxian Multi-Biome Pack`;
    
    const allPresets = getPresets();
    const presetsToProcess = [];

    // 1. Gather User Selections
    const mainCheckboxes = document.querySelectorAll('#multiExportPresetList input[type="checkbox"][id^="preset_main_"]');
    
    mainCheckboxes.forEach(cb => {
        if (cb.checked) {
            const name = cb.dataset.presetName;
            const serverCb = document.getElementById(`sub_server_${name}`);
            const clientCb = document.getElementById(`sub_client_${name}`);
            
            presetsToProcess.push({
                name: name,
                includeServer: serverCb ? serverCb.checked : false,
                includeClient: clientCb ? clientCb.checked : false
            });
        }
    });

    if (presetsToProcess.length === 0) {
        showSnackbar("Please select at least one preset to export.");
        return;
    }

    document.getElementById('multiExportModalOverlay').style.display = 'none';

    // 2. Setup MCADDON Structure
    const zip = new JSZip();
    
    // Generate UUIDs for Dependency Linking
    const bpHeaderUuid = generateUuidv4();
    const bpModuleUuid = generateUuidv4();
    const rpHeaderUuid = generateUuidv4();
    const rpModuleUuid = generateUuidv4();

    // Create Folders
    const bpFolder = zip.folder(packName.replace(/ /g, '_') + "_BP");
    const rpFolder = zip.folder(packName.replace(/ /g, '_') + "_RP");
    const bpBiomes = bpFolder.folder("biomes");
    const rpBiomes = rpFolder.folder("biomes"); // Note: Client biomes usually go in root or biomes, standard is biomes in RP too usually, or root if strictly defined. Let's put in 'biomes' to keep organized, bedrock allows nested.
    
    let addedServerCount = 0;
    let addedClientCount = 0;

    // 3. Process Files
    for (const item of presetsToProcess) {
        const presetData = allPresets[item.name];
        
        // Determine data structure (Legacy vs New)
        const serverData = presetData.server || (presetData['minecraft:biome'] ? presetData : null);
        const clientData = presetData.client || null;

        // --- Add Server File ---
        if (item.includeServer && serverData) {
            const id = serverData['minecraft:biome']?.description?.identifier;
            if (id) {
                const fileName = id.split(':')[1].replace(/[^a-z0-9._-]/g, '_') + '.biome.json';
                bpBiomes.file(fileName, JSON.stringify(serverData, null, 2));
                addedServerCount++;
            }
        }

        // --- Add Client File ---
        if (item.includeClient && clientData) {
            const id = clientData['minecraft:client_biome']?.description?.identifier;
            if (id) {
                const fileName = id.split(':')[1].replace(/[^a-z0-9._-]/g, '_') + '.client_biome.json';
                // Note: Client Biomes in RP usually work best when referencing the ID.
                // We put them in the 'biomes' folder of RP.
                rpBiomes.file(fileName, JSON.stringify(clientData, null, 2));
                addedClientCount++;
            }
        }
    }

    // 4. Generate Manifests
    const bpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} BP`,
            "description": `Contains ${addedServerCount} biomes. Generated by Wanxian.`,
            "uuid": bpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [{ "type": "data", "uuid": bpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": rpHeaderUuid, "version": [1, 0, 0] }]
    };

    const rpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} RP`,
            "description": `Contains ${addedClientCount} client biomes. Generated by Wanxian.`,
            "uuid": rpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [{ "type": "resources", "uuid": rpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": bpHeaderUuid, "version": [1, 0, 0] }]
    };

    bpFolder.file("manifest.json", JSON.stringify(bpManifest, null, 2));
    rpFolder.file("manifest.json", JSON.stringify(rpManifest, null, 2));

    // 5. Add Icons
    try {
        const response = await fetch('icons/icon3.png');
        if (response.ok) {
            const blob = await response.blob();
            bpFolder.file("pack_icon.png", blob);
            rpFolder.file("pack_icon.png", blob);
        }
    } catch (e) { console.warn("Icon fetch failed", e); }

    // 6. Export .mcaddon
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName.replace(/ /g, '_')}.mcaddon`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showSnackbar(`Exported .mcaddon with ${addedServerCount} BP & ${addedClientCount} RP files!`);
    } catch (error) {
        showModal({title: 'Export Error', message: error.message, onConfirm: ()=>{}});
    }
}

			
			
			// --- Event Listeners ---
			
			document.addEventListener('DOMContentLoaded', () => {
			    _initializeForm();
			    updatePresetDropdown();
			    document.getElementById('savePresetButton').addEventListener('click', handleSavePreset);
			    document.getElementById('loadPresetButton').addEventListener('click', handleLoadPreset);
			    document.getElementById('deletePresetButton').addEventListener('click', handleDeletePreset);
			    document.getElementById('exportMultipleButton').addEventListener('click', handleExportMultiple);
			});
			
			// --- Your Original Script (Refactored for Integration) ---
			
			let generateFullBiomeJson;
			let _populateFormFromJson;
			let _initializeForm;
			let resetForm;
			
			(function() {
			    let dynamicElementCounter = 0;
			
			    const VANILLA_BIOMES = [
			        "minecraft:bamboo_jungle_hills", "minecraft:bamboo_jungle", "minecraft:beach",
			        "minecraft:birch_forest_hills_mutated", "minecraft:birch_forest_hills",
			        "minecraft:birch_forest_mutated", "minecraft:birch_forest", "minecraft:cherry_grove",
			        "minecraft:cold_beach", "minecraft:cold_ocean", "minecraft:cold_taiga_hills",
			        "minecraft:cold_taiga_mutated", "minecraft:cold_taiga", "minecraft:deep_cold_ocean",
			        "minecraft:deep_dark", "minecraft:deep_frozen_ocean", "minecraft:deep_lukewarm_ocean",
			        "minecraft:deep_ocean", "minecraft:deep_warm_ocean", "minecraft:desert_hills",
			        "minecraft:desert_mutated", "minecraft:desert", "minecraft:dripstone_caves",
			        "minecraft:extreme_hills_edge", "minecraft:extreme_hills_mutated",
			        "minecraft:extreme_hills_plus_trees_mutated", "minecraft:extreme_hills_plus_trees",
			        "minecraft:extreme_hills", "minecraft:flower_forest", "minecraft:forest_hills",
			        "minecraft:forest", "minecraft:frozen_ocean", "minecraft:frozen_peaks",
			        "minecraft:frozen_river", "minecraft:grove", "minecraft:ice_mountains",
			        "minecraft:ice_plains_spikes", "minecraft:ice_plains", "minecraft:jagged_peaks",
			        "minecraft:jungle_edge_mutated", "minecraft:jungle_edge", "minecraft:jungle_hills",
			        "minecraft:jungle_mutated", "minecraft:jungle", "minecraft:legacy_frozen_ocean",
			        "minecraft:lukewarm_ocean", "minecraft:lush_caves", "minecraft:mangrove_swamp",
			        "minecraft:meadow", "minecraft:mega_taiga_hills", "minecraft:mega_taiga",
			        "minecraft:mesa_bryce", "minecraft:mesa_plateau_mutated", "minecraft:mesa_plateau_stone_mutated",
			        "minecraft:mesa_plateau_stone", "minecraft:mesa_plateau", "minecraft:mesa",
			        "minecraft:mushroom_island_shore", "minecraft:mushroom_island", "minecraft:ocean",
			        "minecraft:pale_garden", "minecraft:plains", "minecraft:redwood_taiga_hills_mutated",
			        "minecraft:redwood_taiga_mutated", "minecraft:river", "minecraft:roofed_forest_mutated",
			        "minecraft:roofed_forest", "minecraft:savanna_mutated", "minecraft:savanna_plateau_mutated",
			        "minecraft:savanna_plateau", "minecraft:savanna", "minecraft:snowy_slopes",
			        "minecraft:stone_beach", "minecraft:stony_peaks", "minecraft:sunflower_plains",
			        "minecraft:swampland_mutated", "minecraft:swampland", "minecraft:taiga_hills",
			        "minecraft:taiga_mutated", "minecraft:taiga", "minecraft:warm_ocean",
			      "minecraft:warped_forest",
			      "minecraft:the_end",
			      "minecraft:soulsand_valley",
			      "minecraft:crimson_forest",
			      "minecraft:hell",
			      "minecraft:basalt_deltas"
			    ];
			
			    const BIOME_TAGS = [
			        "animal", "ash", "bamboo", "basalt_deltas", "beach", "bee_habitat", "birch", "caves", "cherry_grove",
			        "cold", "crimson_forest", "deep", "deep_dark", "desert", "dripstone_caves", "edge", "extreme_hills",
			        "flower_forest", "forest", "forest_generation", "frozen", "frozen_peaks", "grove", "has_structure_trail_ruins",
			        "hills", "ice", "ice_plains", "jagged_peaks", "jungle", "lukewarm", "lush_caves", "mangrove_swamp",
			        "meadow", "mega", "mesa", "monster", "mooshroom_island", "mountain", "mountains", "mutated", "nether",
			        "nether_wastes", "netherwart_forest", "no_legacy_worldgen", "ocean", "overworld", "overworld_generation",
			        "pale_garden", "plains", "plateau", "rare", "river", "roofed", "savanna", "shore", "snowy_slopes",
			        "soulsand_valley", "spawn_endermen", "spawn_few_piglins", "spawn_few_zombified_piglins", "spawn_ghast",
			        "spawn_magma_cubes", "spawn_many_magma_cubes", "spawn_piglin", "spawn_zombified_piglin", "stone",
			        "stony_peaks", "swamp", "taiga", "the_end", "underwater", "warm", "warped_forest"
			    ].sort();
			
			    function populateBiomeSelect(selectElementId) {
			        const select = document.getElementById(selectElementId);
			        select.innerHTML = '';
			        VANILLA_BIOMES.forEach(biome => {
			            const option = document.createElement('option');
			            option.value = biome;
			            option.textContent = biome;
			            select.appendChild(option);
			        });
			    }
			
			    function setupCollapsibleSections() {
			        document.querySelectorAll('.collapsible-header').forEach(header => {
			            const toggleCheckbox = header.querySelector('.component-toggle');
			            const content = document.getElementById(header.dataset.target);
			
			            if (toggleCheckbox) {
			                content.style.display = 'none';
			                header.classList.add('collapsed');
			                toggleRequiredFields(content, false);
			
			                header.addEventListener('click', (event) => {
			                    if (event.target.closest('.switch')) {
			                        event.stopPropagation();
			                        return;
			                    }
			                    toggleCheckbox.checked = !toggleCheckbox.checked;
			                    toggleCheckbox.dispatchEvent(new Event('change'));
			                });
			
			                toggleCheckbox.addEventListener('change', () => {
			                    content.style.display = toggleCheckbox.checked ? 'block' : 'none';
			                    header.classList.toggle('collapsed', !toggleCheckbox.checked);
			                    toggleRequiredFields(content, toggleCheckbox.checked);
			                });
			            }
			        });
			    }
			
			    function toggleRequiredFields(container, isEnabled) {
			        container.querySelectorAll('input, select, textarea').forEach(input => {
			            if (input.dataset.originalRequired === 'true') {
			                input.required = isEnabled;
			            }
			        });
			    }
			
			    function populateBiomeTags() {
			        const select = document.getElementById('biome_tags_select');
			        select.innerHTML = '';
			        BIOME_TAGS.forEach(tag => {
			            const option = document.createElement('option');
			            option.value = tag;
			            option.textContent = tag;
			            select.appendChild(option);
			        });
			    }
			
			    function createBlockSpecifierInputs(containerElement, prefix = '', initialData = null, labelText = 'Block Name', isNameRequired = true) {
			        let initialName = '';
			        let initialStates = null;
			        let areStatesEnabled = false;
			
			        if (typeof initialData === 'string') {
			            initialName = initialData;
			        } else if (typeof initialData === 'object' && initialData !== null) {
			            initialName = initialData.name || '';
			            if (initialData.states && Object.keys(initialData.states).length > 0) {
			                initialStates = initialData.states;
			                areStatesEnabled = true;
			            }
			        }
			
			        const blockNameId = `${prefix}name`;
			        const blockStatesId = `${prefix}states`;
			        const toggleStatesId = `toggle_${prefix}states`;
			        const statesGroupDivId = `${prefix}states_group`;
			        
			        containerElement.innerHTML = '';
			
			        const nameGroup = document.createElement('div');
			        nameGroup.classList.add('form-group');
			        nameGroup.innerHTML = `
			            <label for="${blockNameId}" ${isNameRequired ? 'class="required-field"' : ''}>${labelText}:</label>
			            <input type="text" id="${blockNameId}" placeholder="e.g., minecraft:dirt" value="${initialName}" ${isNameRequired ? 'required' : ''}>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">Name of the block. Example: "minecraft:stone"</span>
			            </div>`;
			        containerElement.appendChild(nameGroup);
			
			        const optionalStatesContainer = document.createElement('div');
			        optionalStatesContainer.classList.add('optional-input-container');
			        optionalStatesContainer.innerHTML = `
			            <div class="switch-container">
			                <label for="${toggleStatesId}">Enable States (Optional):</label>
			                <label class="switch">
			                    <input type="checkbox" id="${toggleStatesId}" class="optional-input-toggle" ${areStatesEnabled ? 'checked' : ''}>
			             <span class="slider"></span>       
			                </label>
			            </div>
			            <div id="${statesGroupDivId}" class="optional-input-content" style="display: ${areStatesEnabled ? 'block' : 'none'};">
			                <div class="form-group">
			                    <label for="${blockStatesId}">Block States (JSON Object):</label>
			                    <textarea id="${blockStatesId}" rows="2" placeholder='{"state_name": "value"}'>${initialStates ? JSON.stringify(initialStates, null, 2) : ''}</textarea>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Contains members named after each state, with boolean, integer, or string values. Example: {"direction": "north"}</span>
			                    </div>
			                </div>
			            </div>`;
			        containerElement.appendChild(optionalStatesContainer);
			        
			        const nameInput = containerElement.querySelector(`#${blockNameId}`);
			        if (nameInput && isNameRequired) nameInput.dataset.originalRequired = 'true';
			
			        const toggleCheckbox = containerElement.querySelector(`#${toggleStatesId}`);
			        const statesContent = containerElement.querySelector(`#${statesGroupDivId}`);
			        const statesTextarea = containerElement.querySelector(`#${blockStatesId}`);
			        
			        toggleCheckbox.addEventListener('change', () => {
			            statesContent.style.display = toggleCheckbox.checked ? 'block' : 'none';
			            if (!toggleCheckbox.checked) statesTextarea.value = '';
			        });
			    }
			    
			    function createBlockSpecifierGroup(uniqueIdPrefix, initialData = null) {
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        
			        let initialName = '';
			        let initialStates = null;
			        let areStatesEnabled = false;
			
			        if (typeof initialData === 'string') {
			            initialName = initialData;
			        } else if (typeof initialData === 'object' && initialData !== null) {
			            initialName = initialData.name || '';
			            if (initialData.states && Object.keys(initialData.states).length > 0) {
			                initialStates = initialData.states;
			                areStatesEnabled = true;
			            }
			        }
			
			        const toggleStatesId = `toggle_${uniqueIdPrefix}states`;
			        const statesGroupDivId = `${uniqueIdPrefix}states_group`;
			        div.innerHTML = `
			            <h4>Block Specifier</h4>
			            <div class="form-group">
			                <label for="${uniqueIdPrefix}name" class="required-field">Block Name:</label>
			                <input type="text" id="${uniqueIdPrefix}name" placeholder="e.g., minecraft:stone" value="${initialName}" required>
			            </div>
			            <div class="optional-input-container">
			                <div class="switch-container">
			                    <label for="${toggleStatesId}">Enable States (Optional):</label>
			                    <label class="switch">
			                        <input type="checkbox" id="${toggleStatesId}" class="optional-input-toggle" ${areStatesEnabled ? 'checked' : ''}>
			                        
			                  <span class="slider"></span>  </label>
			                </div>
			                <div id="${statesGroupDivId}" class="optional-input-content" style="display: ${areStatesEnabled ? 'block' : 'none'};">
			                    <div class="form-group">
			                        <label for="${uniqueIdPrefix}states">Block States (JSON Object):</label>
			                        <textarea id="${uniqueIdPrefix}states" rows="2" placeholder='{"key": "value"}'>${initialStates ? JSON.stringify(initialStates, null, 2) : ''}</textarea>
			                    </div>
			                </div>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Block Specifier
			            </button>`;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        
			        const nameInput = div.querySelector(`#${uniqueIdPrefix}name`);
			        nameInput.dataset.originalRequired = 'true';
			        
			        const toggleCheckbox = div.querySelector(`#${toggleStatesId}`);
			        const statesContent = div.querySelector(`#${statesGroupDivId}`);
			        const statesTextarea = div.querySelector(`#${uniqueIdPrefix}states`);
			        
			        toggleCheckbox.addEventListener('change', () => {
			            statesContent.style.display = toggleCheckbox.checked ? 'block' : 'none';
			            if (!toggleCheckbox.checked) statesTextarea.value = '';
			        });
			        
			        return div;
			    }
			
			
			    function addClimateCategoryEntry(category = '', weight = '') {
			        const container = document.getElementById('generate_for_climates_container');
			        const uniqueId = `climate_category_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        div.innerHTML = `
			            <div class="form-group">
			                <label for="${uniqueId}category" class="required-field">Climate Category:</label>
			                <select id="${uniqueId}category" required>
			                    <option value="">--Select Category--</option>
			                    <option value="medium">medium</option>
			                    <option value="warm">warm</option>
			                    <option value="lukewarm">lukewarm</option>
			                    <option value="cold">cold</option>
			                    <option value="frozen">frozen</option>
			                </select>
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}weight" class="required-field">Weight (Integer, Positive):</label>
			                <input type="number" min="1" step="1" id="${uniqueId}weight" placeholder="e.g., 1" required>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Category
			            </button>`;
			        container.appendChild(div);
			        div.querySelector(`#${uniqueId}category`).value = category;
			        div.querySelector(`#${uniqueId}weight`).value = weight;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');
			            // --- ADDED: Initialize the new multi-select UI immediately ---
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }
    // -------------------------------------------------------------
			        return div;
			    }
			
			    function addWeightedBiomeEntry(containerId, biomeName = '', weight = '') {
			        const container = document.getElementById(containerId);
			        const uniqueId = `${containerId.replace('_container', '')}_entry_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('dynamic-item', 'form-group');
			        div.innerHTML = `
			            <label for="${uniqueId}biome" class="required-field">Biome Name:</label>
			            <select id="${uniqueId}biome" required></select>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">Select a biome name.</span>
			            </div>
			            <label for="${uniqueId}weight" class="required-field">Weight (Integer, Positive):</label>
			            <input type="number" min="1" step="1" id="${uniqueId}weight" placeholder="e.g., 1" value="${weight}" required>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">The weight of this biome relative to others in the list.</span>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove
			            </button>`;
			        container.appendChild(div);
			        const biomeSelect = div.querySelector(`#${uniqueId}biome`);
			        VANILLA_BIOMES.forEach(biome => {
			            const option = document.createElement('option');
			            option.value = biome;
			            option.textContent = biome;
			            biomeSelect.appendChild(option);
			        });
			        biomeSelect.value = biomeName;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');
			            // --- ADDED: Initialize the new multi-select UI immediately ---
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }
    // -------------------------------------------------------------
			        return div;
			    }
			
			    function addMaterialAdjustmentEntry(adjustmentData = {}) {
			        const { noise_range = [], height_range = [], noise_frequency_scale = '', materials = {} } = adjustmentData;
			        const container = document.getElementById('material_adjustments_container');
			        const uniqueId = `material_adj_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        div.innerHTML = `
			            <h4>Material Adjustment</h4>
			            <div class="form-group">
			                <label>Noise Range (Min, Max - Array of 2 Floats):</label>
			                <input type="number" step="0.01" id="${uniqueId}noise_min" placeholder="e.g., 0.2" value="${noise_range[0] || ''}">
			                <input type="number" step="0.01" id="${uniqueId}noise_max" placeholder="e.g., 0.5" value="${noise_range[1] || ''}">
			            </div>
			            <div class="form-group">
			                <label>Height Range (Min, Max - Array of 2 Molang expressions):</label>
			                <input type="text" id="${uniqueId}height_min" placeholder="e.g., 0" value="${height_range[0] || ''}">
			                <input type="text" id="${uniqueId}height_max" placeholder="e.g., 100" value="${height_range[1] || ''}">
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}noise_freq_scale">Noise Frequency Scale (Float):</label>
			                <input type="number" step="0.01" id="${uniqueId}noise_freq_scale" placeholder="e.g., 1.0" value="${noise_frequency_scale}">
			            </div>
			            <h5>Materials</h5>
			            <div class="sub-group" id="${uniqueId}materials_container">
			                <!-- Material specifiers will be added here -->
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Adjustment
			            </button>`;
			        container.appendChild(div);
			
			        const materialsContainer = div.querySelector(`#${uniqueId}materials_container`);
			        const materialTypes = ['top_material', 'foundation_material', 'mid_material', 'sea_floor_material', 'sea_material'];
			
			        materialTypes.forEach(matType => {
			            const matData = materials[matType];
			            const matContainerId = `${uniqueId}${matType}_container`;
			            const matGroupId = `${uniqueId}${matType}_group`;
			            const matEnableId = `${uniqueId}enable_${matType}`;
			            
			            const optionalContainer = document.createElement('div');
			            optionalContainer.className = 'optional-input-container';
			            optionalContainer.innerHTML = `
			                <div class="switch-container">
			                    <label for="${matEnableId}">Enable ${matType.replace(/_/g, ' ')} (Optional):</label>
			                    <label class="switch">
			                        <input type="checkbox" id="${matEnableId}" class="optional-input-toggle" ${matData ? 'checked' : ''}>
			                        
			           <span class="slider"></span>         </label>
			                </div>
			                <div id="${matGroupId}" class="optional-input-content" style="display: ${matData ? 'block' : 'none'};">
			                    <div class="form-group" id="${matContainerId}"></div>
			                </div>`;
			            materialsContainer.appendChild(optionalContainer);
			            
			            const blockSpecContainer = div.querySelector(`#${matContainerId}`);
			            createBlockSpecifierInputs(blockSpecContainer, `${uniqueId}${matType}_`, matData, `${matType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (Block Specifier)`, false);
			
			            const enableToggle = div.querySelector(`#${matEnableId}`);
			            const contentGroup = div.querySelector(`#${matGroupId}`);
			            enableToggle.addEventListener('change', () => {
			                contentGroup.style.display = enableToggle.checked ? 'block' : 'none';
			            });
			        });
			
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        return div;
			    }
			    
			    function addReplacementEntry(replacementData = {}) {
    const {
        dimension = 'minecraft:overworld',
        amount = '',
        noise_frequency_scale = '',
        targets = []
    } = replacementData;

    const container = document.getElementById('replacements_list_container');
    const uniqueId = `replacement_${Date.now()}_${dynamicElementCounter++}_`;
    const div = document.createElement('div');
    div.classList.add('sub-group', 'dynamic-item');

    let optionsHtml = '';
    VANILLA_BIOMES.forEach(biome => {
        const isSelected = targets.includes(biome);
        optionsHtml += `<option value="${biome}" ${isSelected ? 'selected' : ''}>${biome}</option>`;
    });

    // Handle custom biomes from loaded data that aren't in vanilla list
    targets.forEach(target => {
        if (!VANILLA_BIOMES.includes(target)) {
            optionsHtml += `<option value="${target}" selected>${target}</option>`;
        }
    });

    // Define defaults for sliders if empty
    const defaultAmount = amount !== '' ? amount : 0.7;
    const defaultScale = noise_frequency_scale !== '' ? noise_frequency_scale : 42.0;

    div.innerHTML = `
        <h4>Replacement Rule</h4>
        <div class="form-group">
            <label class="required-field">Target Dimension:</label>
            <div class="radio-group">
                <label class="radio-container">Overworld
                    <input type="radio" name="${uniqueId}dimension" value="minecraft:overworld" ${dimension === 'minecraft:overworld' ? 'checked' : ''}>
                    <span class="radio-checkmark"></span>
                </label>
                <label class="radio-container">Nether
                    <input type="radio" name="${uniqueId}dimension" value="minecraft:nether" ${dimension === 'minecraft:nether' ? 'checked' : ''}>
                    <span class="radio-checkmark"></span>
                </label>
            </div>
        </div>

        <div class="form-group">
            <label for="${uniqueId}amount" class="required-field">Amount (Float, 0.0 - 1.0]:</label>
            <input type="number" step="any" min="0.001" max="1.0" id="${uniqueId}amount" value="${defaultAmount}" style="display:none;" required>
            <div class="custom-slider-replacement" 
                 data-target-id="${uniqueId}amount" 
                 data-min-value="0.001" 
                 data-max-value="1.0" 
                 data-decimal-places="3" 
                 data-initial-value="${defaultAmount}"></div>
        </div>

        <div class="form-group">
            <label for="${uniqueId}noise_freq_scale" class="required-field">Noise Frequency Scale (Float, 0.0 - 100.0]:</label>
            <input type="number" step="any" min="0.001" max="100.0" id="${uniqueId}noise_freq_scale" value="${defaultScale}" style="display:none;" required>
            <div class="custom-slider-replacement" 
                 data-target-id="${uniqueId}noise_freq_scale" 
                 data-min-value="0.001" 
                 data-max-value="100.0" 
                 data-decimal-places="3" 
                 data-initial-value="${defaultScale}"></div>
        </div>

        <div class="form-group">
            <label for="${uniqueId}targets_select" class="required-field">Targets (Multi-select Biome Names):</label>
            
            <div style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                <input type="text" id="${uniqueId}custom_biome" placeholder="namespace:custom_biome" style="margin-bottom: 0; flex-grow: 1;">
                <button type="button" class="button add-button" id="${uniqueId}add_custom_btn" style="margin: 0; height: 50px;">
                    <span class="material-symbols-rounded">add</span>
                </button>
            </div>

            <select id="${uniqueId}targets_select" multiple size="8" required>
                ${optionsHtml}
            </select>
        </div>
        <button type="button" class="button remove-button">
            <span class="material-symbols-rounded">remove</span>
            Remove Replacement
        </button>
    `;
    
    container.appendChild(div);

    // 1. Initialize Sliders for this new entry
    div.querySelectorAll('.custom-slider-replacement').forEach(window.initCustomSlider);

    // 2. Initialize Multi-Select UI
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }

    // 3. Logic for Adding Custom Biomes
    const addCustomBtn = div.querySelector(`#${uniqueId}add_custom_btn`);
    const customInput = div.querySelector(`#${uniqueId}custom_biome`);
    const select = div.querySelector(`#${uniqueId}targets_select`);

    addCustomBtn.addEventListener('click', () => {
        const val = customInput.value.trim().toLowerCase();
        
        // Basic Validation
        if (!val) {
            alert("Please enter a biome identifier.");
            return;
        }
        if (!/^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/.test(val)) {
            alert("Invalid format. Use namespace:biome_name.");
            return;
        }

        // Check for duplicates
        let exists = false;
        for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === val) {
                exists = true;
                select.options[i].selected = true; // Just select it if exists
                break;
            }
        }

        if (!exists) {
            // Add new option and select it
            const opt = new Option(val, val, true, true);
            select.add(opt);
        }

        // Clear input
        customInput.value = '';

        // INSTANTLY UPDATE THE MULTI-SELECT TRIGGER UI
        // The trigger is inserted immediately after the select by initMultiSelects
        const trigger = select.nextSibling; 
        if (trigger && trigger.classList.contains('m3-select-trigger')) {
            const textSpan = trigger.querySelector('.selection-text');
            if (textSpan && typeof updateTriggerText === 'function') {
                updateTriggerText(select, textSpan);
            }
        }
    });

    div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
    div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');

    return div;
}

			
			    function getBlockSpecifierFromGroup(containerElement) {
			        const nameInput = containerElement.querySelector('input[id$="name"]');
			        const statesTextarea = containerElement.querySelector('textarea[id$="states"]');
			        const toggleStatesCheckbox = containerElement.querySelector('input[id^="toggle_"][id$="states"]');
			
			        const name = nameInput?.value.trim();
			        if (!name) return null;
			
			        if (!toggleStatesCheckbox || !toggleStatesCheckbox.checked) {
			            return name; // Return as a simple string
			        }
			
			        const blockSpec = { name: name };
			        if (statesTextarea?.value.trim()) {
			            try {
			                const states = JSON.parse(statesTextarea.value.trim());
			                if (Object.keys(states).length > 0) {
			                    blockSpec.states = states;
			                }
			            } catch (e) {
			                showModal({title: 'JSON Parse Error', message: `Invalid JSON for states in block specifier "${name}".`, onConfirm: ()=>{}});
			                throw e;
			            }
			        }
			        
			        // If states are enabled but empty, just return the object with the name.
			        return blockSpec;
			    }
			
			    const appendSingleBlockSpecifierInput = (parentContainer, inputName, initialData = null, isRequired = true) => {
			        const div = document.createElement('div');
			        div.classList.add('form-group');
			        parentContainer.appendChild(div);
			        const formattedLabel = `${inputName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (Block Specifier)`;
			        createBlockSpecifierInputs(div, `sb_${inputName}_`, initialData, formattedLabel, isRequired);
			    };
			
			    const appendMultiBlockSpecifierSection = (parentContainer, materialName, initialMaterials = []) => {
			        const uniqueIdPrefix = 'sb_';
			        const sectionDiv = document.createElement('div');
			        sectionDiv.classList.add('form-group');
			        sectionDiv.innerHTML = `
			            <label class="required-field">${materialName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</label>
			            <button type="button" class="button add-button" id="add_${materialName}_button">
			                <span class="material-symbols-rounded">add</span>
			                Add Block Specifier
			            </button>
			            <div id="${uniqueIdPrefix}${materialName}_list_container"></div>`;
			        parentContainer.appendChild(sectionDiv);
			        const listContainer = document.getElementById(`${uniqueIdPrefix}${materialName}_list_container`);
			        initialMaterials.forEach(material => {
			            dynamicElementCounter++;
			            const newBlockSpecifierGroup = createBlockSpecifierGroup(`${uniqueIdPrefix}${materialName}_${Date.now()}_${dynamicElementCounter}`, material);
			            listContainer.appendChild(newBlockSpecifierGroup);
			        });
			        document.getElementById(`add_${materialName}_button`).addEventListener('click', () => {
			            dynamicElementCounter++;
			            const newBlockSpecifierGroup = createBlockSpecifierGroup(`${uniqueIdPrefix}${materialName}_${Date.now()}_${dynamicElementCounter}`);
			            listContainer.appendChild(newBlockSpecifierGroup);
			        });
			    };
			
			    function renderSurfaceBuilderFields(builderType, builderData = {}) {
			        const container = document.getElementById('surface_builder_dynamic_fields');
			        container.innerHTML = '';
			        if (!builderType) return;
			
			        switch (builderType) {
			            case "minecraft:overworld":
			            case "minecraft:frozen_ocean":
			            case "minecraft:swamp":
			                const seaFloorDepthDiv = document.createElement('div');
			                seaFloorDepthDiv.classList.add('form-group');
			                seaFloorDepthDiv.innerHTML = `
			                    <label for="sb_sea_floor_depth" class="required-field">Sea Floor Depth (Integer):</label>
			                    <input type="number" step="1" id="sb_sea_floor_depth" value="${builderData.sea_floor_depth || ''}" required>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Controls how deep below the world water level the floor should occur.</span>
			                    </div>`;
			                container.appendChild(seaFloorDepthDiv);
			                appendSingleBlockSpecifierInput(container, 'sea_floor_material', builderData.sea_floor_material);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'mid_material', builderData.mid_material);
			                appendSingleBlockSpecifierInput(container, 'top_material', builderData.top_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			
			                 if (builderType === "minecraft:swamp") {
			                    const maxPuddleDepthDiv = document.createElement('div');
			                    maxPuddleDepthDiv.classList.add('form-group');
			                    maxPuddleDepthDiv.innerHTML = `
			                        <label for="sb_max_puddle_depth_below_sea_level" class="required-field">Max Puddle Depth Below Sea Level (Integer):</label>
			                        <input type="number" step="1" min="0" max="127" id="sb_max_puddle_depth_below_sea_level" value="${builderData.max_puddle_depth_below_sea_level || ''}" required>
			                        <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                            <span class="tooltiptext">Controls the depth at which surface level blocks can be replaced with water for puddles.</span>
			                        </div>`;
			                    container.appendChild(maxPuddleDepthDiv);
			                }
			                break;
			            case "minecraft:mesa":
			                const mesaSeaFloorDepthDiv = document.createElement('div');
			                mesaSeaFloorDepthDiv.classList.add('form-group');
			                mesaSeaFloorDepthDiv.innerHTML = `
			                    <label for="sb_sea_floor_depth" class="required-field">Sea Floor Depth (Integer):</label>
			                    <input type="number" step="1" id="sb_sea_floor_depth" value="${builderData.sea_floor_depth || ''}" required>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Controls how deep below the world water level the floor should occur.</span>
			                    </div>`;
			                container.appendChild(mesaSeaFloorDepthDiv);
			
			                appendSingleBlockSpecifierInput(container, 'sea_floor_material', builderData.sea_floor_material);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'mid_material', builderData.mid_material);
			                appendSingleBlockSpecifierInput(container, 'top_material', builderData.top_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			
			                const brycePillarsDiv = document.createElement('div');
			                brycePillarsDiv.classList.add('switch-container');
			                brycePillarsDiv.innerHTML = `
			                    <label for="sb_bryce_pillars" class="required-field">Bryce Pillars:</label>
			                    <label class="switch">
			                        <input type="checkbox" id="sb_bryce_pillars" ${builderData.bryce_pillars ? 'checked' : ''}>
			                        
			           <span class="slider"></span>         </label>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Whether the mesa generates with pillars.</span>
			                    </div>`;
			                container.appendChild(brycePillarsDiv);
			
			                appendSingleBlockSpecifierInput(container, 'clay_material', builderData.clay_material);
			                appendSingleBlockSpecifierInput(container, 'hard_clay_material', builderData.hard_clay_material);
			
			                const hasForestDiv = document.createElement('div');
			                hasForestDiv.classList.add('switch-container');
			                hasForestDiv.innerHTML = `
			                    <label for="sb_has_forest" class="required-field">Has Forest:</label>
			                    <label class="switch">
			                        <input type="checkbox" id="sb_has_forest" ${builderData.has_forest ? 'checked' : ''}>
			          <span class="slider"></span>              
			                    </label>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Places coarse dirt and grass at high altitudes.</span>
			                    </div>`;
			                container.appendChild(hasForestDiv);
			                break;
			            case "minecraft:capped":
			                appendSingleBlockSpecifierInput(container, 'beach_material', builderData.beach_material, false); // Beach is optional
			                appendMultiBlockSpecifierSection(container, 'ceiling_materials', builderData.ceiling_materials || []);
			                appendMultiBlockSpecifierSection(container, 'floor_materials', builderData.floor_materials || []);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			                break;
			        }
			        container.querySelectorAll('input[required], select[required], textarea[required]').forEach(input => input.dataset.originalRequired = 'true');
			    }
			
			    function addCustomTag(tagValue = '') {
			        const customTagInput = document.getElementById('custom_tag_input');
			        const tag = tagValue || customTagInput.value.trim().toLowerCase();
			        if (!tag) {
			            showModal({title: 'Input Error', message: "Custom tag cannot be empty.", onConfirm: ()=>{}});
			            return;
			        }
			        if (!/^[a-z0-9._]+$/.test(tag)) {
			            showModal({title: 'Input Error', message: "Custom tags should only contain lowercase alphanumeric characters, periods, and underscores.", onConfirm: ()=>{}});
			            return;
			        }
			        const predefinedTags = Array.from(document.getElementById('biome_tags_select').options).map(opt => opt.value);
			        if (predefinedTags.includes(tag) || customTags.includes(tag)) {
			            if (!tagValue) showModal({title: 'Duplicate Tag', message: `Tag "${tag}" already exists.`, onConfirm: ()=>{}});
			            return;
			        }
			        customTags.push(tag);
			        customTags.sort();
			        renderCustomTags();
			        if (!tagValue) customTagInput.value = '';
			    }
			
			    function renderCustomTags() {
			        const displayContainer = document.getElementById('custom_tags_display');
			        displayContainer.innerHTML = '';
			        customTags.forEach(tag => {
			            const tagItem = document.createElement('span');
			            tagItem.classList.add('tag-item');
			            tagItem.textContent = tag;
			            const removeButton = document.createElement('button');
			            removeButton.classList.add('remove-tag-button');
			            removeButton.innerHTML = '&times;';
			            removeButton.title = `Remove ${tag}`;
			            removeButton.onclick = () => removeCustomTag(tag);
			            tagItem.appendChild(removeButton);
			            displayContainer.appendChild(tagItem);
			        });
			    }
			
			    function removeCustomTag(tagToRemove) {
			        customTags = customTags.filter(tag => tag !== tagToRemove);
			        renderCustomTags();
			    }
			
			    function hexToRgb(hex) {
			        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
			        hex = hex.replace(shorthandRegex, function(m, r, g, b) { return r + r + g + g + b + b; });
			        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
			    }
			
			    function rgbToHex(r, g, b) {
			        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
			    }
			
			    function parseColorInput(value) {
			        value = value.trim();
			        if (!value) return null;
			        let rgb = hexToRgb(value);
			        if (rgb) return rgbToHex(rgb.r, rgb.g, rgb.b);
			        const rgbMatch = value.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
			        if (rgbMatch) {
			            const r = parseInt(rgbMatch[1]), g = parseInt(rgbMatch[2]), b = parseInt(rgbMatch[3]);
			            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) return rgbToHex(r, g, b);
			        }
			        return null;
			    }
			
			    function updateColorInputUI(textInput, colorPicker, defaultColor = '#000000') {
			        const applyColor = (color) => { colorPicker.value = color || '#000000'; };
			        const initialParsedColor = parseColorInput(textInput.value);
			        applyColor(initialParsedColor || defaultColor);
			        textInput.addEventListener('input', () => applyColor(parseColorInput(textInput.value)));
			        textInput.addEventListener('blur', () => {
			            const parsedColor = parseColorInput(textInput.value);
			            if (parsedColor) {
			                textInput.value = parsedColor;
			            } else if (textInput.value.trim() !== '') {
			                textInput.value = defaultColor;
			                applyColor(defaultColor);
			            } else {
			                applyColor(null);
			            }
			        });
			        colorPicker.addEventListener('input', () => { textInput.value = colorPicker.value.toUpperCase(); });
			    }
			
    resetForm = function() {
        // Reset Server Form
        document.getElementById('biomeForm').reset();
        
        // Reset Client Form
        document.getElementById('clientBiomeForm').reset();
        
        // Reset Main Client Toggle
        const clientToggle = document.getElementById('enable_clientbiomes');
        clientToggle.checked = false;
        document.getElementById('hidden-container').style.display = 'none';
        // --- ADD THIS BLOCK ---
        const unusedToggle = document.getElementById('show_unused_components');
        const unusedWrapper = document.getElementById('unused_components_wrapper');
        if (unusedToggle) unusedToggle.checked = false;
        if (unusedWrapper) unusedWrapper.style.display = 'none';

        // Reset All Collapsible Sections (Server & Client)
        document.querySelectorAll('.component-toggle').forEach(toggle => {
            toggle.checked = false;
            const header = toggle.closest('.collapsible-header');
            const content = document.getElementById(header.dataset.target);
            if (content) {
                content.style.display = 'none';
                toggleRequiredFields(content, false);
            }
            if (header) header.classList.add('collapsed');
        });

        // Clear Dynamic Server Fields
        document.getElementById('generate_for_climates_container').querySelectorAll('.dynamic-item').forEach(item => item.remove());
        document.getElementById('material_adjustments_container').querySelectorAll('.dynamic-item').forEach(item => item.remove());
        document.getElementById('replacements_list_container').innerHTML = '<h4>Replacements</h4>';
        document.getElementById('surface_builder_dynamic_fields').innerHTML = '';
        
        // Reset Selects
        document.querySelectorAll('select[multiple]').forEach(select => Array.from(select.options).forEach(option => option.selected = false));
        
        // Reset Tags
        customTags = [];
        renderCustomTags();
        
        // Reset Specific Server UI Groups
        document.getElementById('height_noise_type_radio').checked = false;
        document.getElementById('height_noise_params_radio').checked = false;
        document.getElementById('height_noise_type_group').style.display = 'none';
        document.getElementById('noise_type_select').removeAttribute('required');
        document.getElementById('noise_params_depth').removeAttribute('required');
        document.getElementById('noise_params_scale').removeAttribute('required');
        
        document.getElementById('enable_steep_material_adjustment').checked = false;
        document.getElementById('steep_material_adjustment_group').style.display = 'none';
        createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
        
        document.getElementById('steep_north_slopes').checked = false;
        document.getElementById('steep_south_slopes').checked = false;
        document.getElementById('steep_east_slopes').checked = false;
        document.getElementById('steep_west_slopes').checked = false;
        
        document.getElementById('enable_map_tints_foliage').checked = false;
        document.getElementById('map_tints_foliage_group').style.display = 'none';
        document.getElementById('map_tints_foliage_color_input').value = '#6A7039';
        document.getElementById('map_tints_foliage_color_picker').value = '#6A7039';
        
        document.getElementById('grass_tint_type_noise').checked = true;
        document.getElementById('grass_custom_tint_group').style.display = 'none';
        document.getElementById('grass_custom_tint_color_input').removeAttribute('required');
        document.getElementById('grass_custom_tint_color_input').value = '#B6DB61';
        document.getElementById('grass_custom_tint_color_picker').value = '#B6DB61';
        
        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
            document.getElementById(`${transformType}_transform_type_simple`).checked = true;
            document.getElementById(`${transformType}_transform_type_weighted`).checked = false;
            document.getElementById(`${transformType}_transformation_simple_group`).style.display = 'block';
            document.getElementById(`${transformType}_transformation_weighted_group`).style.display = 'none';
            document.getElementById(`${transformType}_weighted_biomes_container`).innerHTML = '';
            populateBiomeSelect(`${transformType}_transformation_select`);
        });

        // Clear Outputs
        document.getElementById('jsonOutput').textContent = '';
        document.getElementById('outputJson').textContent = '';
        
        // Hide Outputs Sections
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'none';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
        
        const clientContent = document.getElementById('client-biome-content');
        clientContent.style.display = 'none';
        clientContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
    }

			
			    _populateFormFromJson = function(jsonData) {
			        try {
			            const biomeData = jsonData['minecraft:biome'];
			            if (!biomeData) throw new Error("Invalid biome JSON: 'minecraft:biome' key not found.");
			            document.getElementById('format_version').value = jsonData.format_version || '';
			            document.getElementById('identifier').value = biomeData.description?.identifier || '';
			            const components = biomeData.components || {};
			            for (const componentName in components) {
			                const componentData = components[componentName];
			                const componentId = componentName.replace('minecraft:', '');
			                const enableToggle = document.getElementById(`enable_${componentId}`);
			                const contentDiv = document.getElementById(`${componentId}-content`);
			                const headerElement = document.querySelector(`.collapsible-header[data-target="${componentId}-content"]`);
			                if (enableToggle) enableToggle.checked = true;
			                if (contentDiv) {
			                    contentDiv.style.display = 'block';
			                    if (headerElement) headerElement.classList.remove('collapsed');
			                    toggleRequiredFields(contentDiv, true);
			                }
			                switch (componentName) {
			                    case 'minecraft:climate':
			                        if (typeof componentData.temperature === 'number') document.getElementById('climate_temperature').value = componentData.temperature;
			                        if (typeof componentData.downfall === 'number') document.getElementById('climate_downfall').value = componentData.downfall;
			                        if (Array.isArray(componentData.snow_accumulation)) {
			                            document.getElementById('climate_snow_acc_min').value = componentData.snow_accumulation[0];
			                            document.getElementById('climate_snow_acc_max').value = componentData.snow_accumulation[1];
			                        }
			                        break;
			                    case 'minecraft:creature_spawn_probability':
    if (typeof componentData.probability === 'number') {
        const el = document.getElementById('creature_spawn_probability_value');
        el.value = componentData.probability;
        if(el.updateSliderUI) el.updateSliderUI(); // Force slider update
    }
    break;
    
// ADD THIS BLOCK AFTER THE PREVIOUS COMPONENT:
case 'minecraft:village_type':
    if (typeof componentData.type === 'string') {
        document.getElementById('enable_village_type').checked = true;
        document.getElementById('village_type_select').value = componentData.type;
    }
    break;

			                    case 'minecraft:humidity':
			                        if (typeof componentData.is_humid === 'boolean') document.getElementById('humidity_is_humid').checked = componentData.is_humid;
			                        break;
			                    case 'minecraft:map_tints':
			                        const enableFoliageToggle = document.getElementById('enable_map_tints_foliage');
			                        const foliageGroup = document.getElementById('map_tints_foliage_group');
			                        const foliageInput = document.getElementById('map_tints_foliage_color_input');
			                        const foliagePicker = document.getElementById('map_tints_foliage_color_picker');
			                        if (componentData.foliage) {
			                            enableFoliageToggle.checked = true;
			                            foliageGroup.style.display = 'block';
			                            foliageInput.value = componentData.foliage;
			                            foliagePicker.value = componentData.foliage;
			                        } else {
			                            enableFoliageToggle.checked = false;
			                            foliageGroup.style.display = 'none';
			                        }
			                        const grassCustomTintGroup = document.getElementById('grass_custom_tint_group');
			                        const grassCustomTintColorInput = document.getElementById('grass_custom_tint_color_input');
			                        const grassCustomTintColorPicker = document.getElementById('grass_custom_tint_color_picker');
			                        if (componentData.grass) {
			                            if (componentData.grass.type === 'tint' && componentData.grass.tint) {
			                                document.getElementById('grass_tint_type_custom').checked = true;
			                                grassCustomTintGroup.style.display = 'block';
			                                grassCustomTintColorInput.value = componentData.grass.tint;
			                                grassCustomTintColorInput.setAttribute('required', true);
			                                grassCustomTintColorPicker.value = componentData.grass.tint;
			                            } else {
			                                document.getElementById('grass_tint_type_noise').checked = true;
			                                grassCustomTintGroup.style.display = 'none';
			                                grassCustomTintColorInput.removeAttribute('required');
			                            }
			                        }
			                        break;
			                    case 'minecraft:mountain_parameters':
			                        if (componentData.top_slide && typeof componentData.top_slide.enabled === 'boolean') {
			                            document.getElementById('top_slide_enabled').checked = componentData.top_slide.enabled;
			                        }
			                        if (componentData.steep_material_adjustment) {
			                            document.getElementById('enable_steep_material_adjustment').checked = true;
			                            document.getElementById('steep_material_adjustment_group').style.display = 'block';
			                            const adj = componentData.steep_material_adjustment;
			                            createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', adj.material, 'Steep Material (Block Specifier)', false);
			                            if (typeof adj.north_slopes === 'boolean') document.getElementById('steep_north_slopes').checked = adj.north_slopes;
			                            if (typeof adj.south_slopes === 'boolean') document.getElementById('steep_south_slopes').checked = adj.south_slopes;
			                            if (typeof adj.east_slopes === 'boolean') document.getElementById('steep_east_slopes').checked = adj.east_slopes;
			                            if (typeof adj.west_slopes === 'boolean') document.getElementById('steep_west_slopes').checked = adj.west_slopes;
			                        } else {
			                            document.getElementById('enable_steep_material_adjustment').checked = false;
			                            document.getElementById('steep_material_adjustment_group').style.display = 'none';
			                            createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
			                        }
			                        break;
			                    case 'minecraft:multinoise_generation_rules':
			                        if (typeof componentData.target_altitude === 'number') document.getElementById('multinoise_target_altitude').value = componentData.target_altitude;
			                        if (typeof componentData.target_humidity === 'number') document.getElementById('multinoise_target_humidity').value = componentData.target_humidity;
			                        if (typeof componentData.target_temperature === 'number') document.getElementById('multinoise_target_temperature').value = componentData.target_temperature;
			                        if (typeof componentData.weirdness === 'number') document.getElementById('multinoise_target_weirdness').value = componentData.weirdness;
			                        if (typeof componentData.weight === 'number') document.getElementById('multinoise_weight').value = componentData.weight;
			                        break;
			                    case 'minecraft:overworld_generation_rules':
			                        if (Array.isArray(componentData.generate_for_climates)) {
			                            componentData.generate_for_climates.forEach(climate => {
			                                if (Array.isArray(climate) && climate.length === 2) addClimateCategoryEntry(climate[0], climate[1]);
			                            });
			                        }
			                        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
			                            const transformData = componentData[`${transformType}_transformation`];
			                            const simpleRadio = document.getElementById(`${transformType}_transform_type_simple`);
			                            const weightedRadio = document.getElementById(`${transformType}_transform_type_weighted`);
			                            const simpleGroup = document.getElementById(`${transformType}_transformation_simple_group`);
			                            const weightedGroup = document.getElementById(`${transformType}_transformation_weighted_group`);
			                            const weightedContainer = document.getElementById(`${transformType}_weighted_biomes_container`);
			                            weightedContainer.innerHTML = '';
			                            if (typeof transformData === 'string') {
			                                simpleRadio.checked = true;
			                                const selectElement = document.getElementById(`${transformType}_transformation_select`);
			                                const option = selectElement.querySelector(`option[value="${transformData}"]`);
			                                if (option) option.selected = true;
			                            } else if (Array.isArray(transformData)) {
			                                const isWeighted = transformData.some(item => Array.isArray(item));
			                                if (isWeighted) {
			                                    weightedRadio.checked = true;
			                                    transformData.forEach(item => {
			                                        if (Array.isArray(item) && item.length === 2) {
			                                            addWeightedBiomeEntry(`${transformType}_weighted_biomes_container`, item[0], item[1]);
			                                        } else if (typeof item === 'string') {
			                                            addWeightedBiomeEntry(`${transformType}_weighted_biomes_container`, item, 1);
			                                        }
			                                    });
			                                } else {
			                                    simpleRadio.checked = true;
			                                    const selectElement = document.getElementById(`${transformType}_transformation_select`);
			                                    transformData.forEach(biomeId => {
			                                        const option = selectElement.querySelector(`option[value="${biomeId}"]`);
			                                        if (option) option.selected = true;
			                                    });
			                                }
			                            }
			                            simpleGroup.style.display = simpleRadio.checked ? 'block' : 'none';
			                            weightedGroup.style.display = weightedRadio.checked ? 'block' : 'none';
			                            toggleRequiredFields(simpleGroup, simpleRadio.checked);
			                            toggleRequiredFields(weightedGroup, weightedRadio.checked);
			                        });
			                        break;
			                    case 'minecraft:overworld_height':
			                        if (componentData.noise_type) {
			                            document.getElementById('height_noise_type_radio').checked = true;
			                            document.getElementById('height_noise_type_group').style.display = 'block';
			                            document.getElementById('noise_type_select').value = componentData.noise_type;
			                            toggleRequiredFields(document.getElementById('height_noise_type_group'), true);
			                        } else if (Array.isArray(componentData.noise_params) && componentData.noise_params.length === 2) {
			                            document.getElementById('height_noise_params_radio').checked = true;
			                            document.getElementById('height_noise_params_group').style.display = 'block';
			                            document.getElementById('noise_params_depth').value = componentData.noise_params[0];
			                            document.getElementById('noise_params_scale').value = componentData.noise_params[1];
			                            toggleRequiredFields(document.getElementById('height_noise_params_group'), true);
			                        }
			                        break;
			                    case 'minecraft:partially_frozen':
			                        break;
			                    case 'minecraft:replace_biomes':
			                        if (Array.isArray(componentData.replacements)) {
			                            componentData.replacements.forEach(replacement => {
			                                addReplacementEntry(replacement);
			                            });
			                        }
			                        break;
			                        break;
			                    case 'minecraft:surface_builder':
			                        if (componentData.builder && componentData.builder.type) {
			                            document.getElementById('surface_builder_type_select').value = componentData.builder.type;
			                            renderSurfaceBuilderFields(componentData.builder.type, componentData.builder);
			                        }
			                        break;
			                    case 'minecraft:surface_material_adjustments':
			                        if (Array.isArray(componentData.adjustments)) {
			                            componentData.adjustments.forEach(adjustment => addMaterialAdjustmentEntry(adjustment));
			                        }
			                        break;
			                    case 'minecraft:tags':
			                        if (Array.isArray(componentData.tags)) {
			                            customTags = [];
			                            const predefinedSelect = document.getElementById('biome_tags_select');
			                            componentData.tags.forEach(tag => {
			                                const option = predefinedSelect.querySelector(`option[value="${tag}"]`);
			                                if (option) {
			                                    option.selected = true;
			                                } else {
			                                    addCustomTag(tag);
			                                }
			                            });
			                            renderCustomTags();
			                        }
			                        break;
			                }
			            }
			        } catch (error) {
			            showModal({title: 'Import Error', message: `Failed to load biome JSON: ${error.message}`, onConfirm: ()=>{}});
			            console.error("Import Error:", error);
			            resetForm();
			        }
			    }
			
			    generateFullBiomeJson = function() {
			        const biomeJson = {};
			        biomeJson.format_version = document.getElementById('format_version').value.trim();
			        if (!biomeJson.format_version) throw new Error("Format Version is required.");
			        const identifier = document.getElementById('identifier').value.trim().toLowerCase();
			        if (!identifier) throw new Error("Biome Identifier is required.");
			        // --- ADDED VALIDATION HERE ---
// Regex pattern: namespace:name (lowercase, numbers, dots, underscores, %, +, -)
const idPattern = /^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/;
if (!idPattern.test(identifier)) {
    throw new Error("Identifier invalid. Use namespace:biome_name pattern (lowercase).");
}
			        biomeJson['minecraft:biome'] = {
			            description: { identifier: identifier },
			            components: {}
			        };
			        const components = biomeJson['minecraft:biome'].components;
			        if (document.getElementById('enable_climate').checked) {
			            const climate = {};
			            const temperature = parseFloat(document.getElementById('climate_temperature').value);
			            if (!isNaN(temperature)) climate.temperature = temperature;
			            const downfall = parseFloat(document.getElementById('climate_downfall').value);
			            if (!isNaN(downfall)) climate.downfall = downfall;
			            const snowAccMin = parseFloat(document.getElementById('climate_snow_acc_min').value);
			            const snowAccMax = parseFloat(document.getElementById('climate_snow_acc_max').value);
			            if (!isNaN(snowAccMin) && !isNaN(snowAccMax)) climate.snow_accumulation = [snowAccMin, snowAccMax];
			            if (Object.keys(climate).length > 0) components['minecraft:climate'] = climate;
			        }
			        if (document.getElementById('enable_creature_spawn_probability').checked) {
			            const probability = parseFloat(document.getElementById('creature_spawn_probability_value').value);
			            if (!isNaN(probability)) components['minecraft:creature_spawn_probability'] = { probability: probability };
			        }
			        
// ADD THIS BLOCK AFTER THE PREVIOUS COMPONENT:
if (document.getElementById('enable_village_type').checked) {
    const villageType = document.getElementById('village_type_select').value;
    components['minecraft:village_type'] = { type: villageType };
}
			        if (document.getElementById('enable_humidity').checked) {
			            components['minecraft:humidity'] = { is_humid: document.getElementById('humidity_is_humid').checked };
			        }
			        if (document.getElementById('enable_map_tints').checked) {
			            const mapTints = {};
			            if (document.getElementById('enable_map_tints_foliage').checked) {
			                const foliageColorInput = document.getElementById('map_tints_foliage_color_input');
			                const foliageColor = parseColorInput(foliageColorInput.value);
			                if (foliageColor) {
			                    mapTints.foliage = foliageColor;
			                } else if (foliageColorInput.value.trim() !== '') {
			                    throw new Error("Invalid foliage tint color format. Please use #RRGGBB or rgb(R,G,B).");
			                }
			            }
			            if (document.getElementById('grass_tint_type_noise').checked) {
			                mapTints.grass = { type: "noise" };
			            } else if (document.getElementById('grass_tint_type_custom').checked) {
			                const customTintColorInput = document.getElementById('grass_custom_tint_color_input');
			                const customTintColor = parseColorInput(customTintColorInput.value);
			                if (customTintColor) {
			                    mapTints.grass = { type: "tint", tint: customTintColor };
			                } else {
			                    throw new Error("Invalid grass custom tint color format. Please use #RRGGBB or rgb(R,G,B).");
			                }
			            } else {
			                throw new Error("Grass tint type (Noise or Custom) is required for minecraft:map_tints.");
			            }
			            if (Object.keys(mapTints).length > 0) components['minecraft:map_tints'] = mapTints;
			        }
			        if (document.getElementById('enable_mountain_parameters').checked) {
			            const mountainParams = {};
			            if (document.getElementById('top_slide_enabled').checked) mountainParams.top_slide = { enabled: true };
			            if (document.getElementById('enable_steep_material_adjustment').checked) {
			                const steepMaterial = getBlockSpecifierFromGroup(document.getElementById('steep_material_container'));
			                const steepMaterialAdjustment = {};
			                if (steepMaterial) steepMaterialAdjustment.material = steepMaterial;
			                if (document.getElementById('steep_north_slopes').checked) steepMaterialAdjustment.north_slopes = true;
			                if (document.getElementById('steep_south_slopes').checked) steepMaterialAdjustment.south_slopes = true;
			                if (document.getElementById('steep_east_slopes').checked) steepMaterialAdjustment.east_slopes = true;
			                if (document.getElementById('steep_west_slopes').checked) steepMaterialAdjustment.west_slopes = true;
			                if (Object.keys(steepMaterialAdjustment).length > 0) mountainParams.steep_material_adjustment = steepMaterialAdjustment;
			            }
			            if (Object.keys(mountainParams).length > 0) components['minecraft:mountain_parameters'] = mountainParams;
			        }
			        if (document.getElementById('enable_multinoise_generation_rules').checked) {
			            const multinoise = {};
			            const altitude = parseFloat(document.getElementById('multinoise_target_altitude').value);
			            if (!isNaN(altitude)) multinoise.target_altitude = altitude;
			            const humidity = parseFloat(document.getElementById('multinoise_target_humidity').value);
			            if (!isNaN(humidity)) multinoise.target_humidity = humidity;
			            const temperature = parseFloat(document.getElementById('multinoise_target_temperature').value);
			            if (!isNaN(temperature)) multinoise.target_temperature = temperature;
			            const weirdness = parseFloat(document.getElementById('multinoise_target_weirdness').value);
			            if (!isNaN(weirdness)) multinoise.target_weirdness = weirdness;
			            const weight = parseFloat(document.getElementById('multinoise_weight').value);
			            if (!isNaN(weight)) multinoise.weight = weight;
			            if (Object.keys(multinoise).length > 0) components['minecraft:multinoise_generation_rules'] = multinoise;
			        }
			        if (document.getElementById('enable_overworld_generation_rules').checked) {
			            const overworldGenRules = {};
			            const generateForClimates = [];
			            document.querySelectorAll('#generate_for_climates_container > .dynamic-item').forEach(item => {
			                const category = item.querySelector('select[id$="category"]').value;
			                const weight = parseInt(item.querySelector('input[id$="weight"]').value);
			                if (category && !isNaN(weight)) generateForClimates.push([category, weight]);
			            });
			            if (generateForClimates.length > 0) overworldGenRules.generate_for_climates = generateForClimates;
			            const getTransformationData = (prefix) => {
			                if (document.getElementById(`${prefix}_transform_type_simple`).checked) {
			                    const selected = Array.from(document.getElementById(`${prefix}_transformation_select`).selectedOptions).map(o => o.value);
			                    return selected.length > 0 ? selected : null;
			                }
			                const weighted = [];
			                document.querySelectorAll(`#${prefix}_weighted_biomes_container > .dynamic-item`).forEach(item => {
			                    const name = item.querySelector('select[id$="biome"]').value;
			                    const weight = parseInt(item.querySelector('input[id$="weight"]').value);
			                    if (name && !isNaN(weight)) weighted.push([name, weight]);
			                });
			                return weighted.length > 0 ? weighted : null;
			            };
			            const hills = getTransformationData('hills');
			            if (hills) overworldGenRules.hills_transformation = hills;
			            const mutate = getTransformationData('mutate');
			            if (mutate) overworldGenRules.mutate_transformation = mutate;
			            const river = getTransformationData('river');
			            if (river) overworldGenRules.river_transformation = river;
			            const shore = getTransformationData('shore');
			            if (shore) overworldGenRules.shore_transformation = shore;
			            if (Object.keys(overworldGenRules).length > 0) components['minecraft:overworld_generation_rules'] = overworldGenRules;
			        }
			        if (document.getElementById('enable_overworld_height').checked) {
			            const overworldHeight = {};
			            if (document.getElementById('height_noise_type_radio').checked) {
			                const noiseType = document.getElementById('noise_type_select').value;
			                if (noiseType) overworldHeight.noise_type = noiseType;
			            } else if (document.getElementById('height_noise_params_radio').checked) {
			                const depth = parseFloat(document.getElementById('noise_params_depth').value);
			                const scale = parseFloat(document.getElementById('noise_params_scale').value);
			                if (!isNaN(depth) && !isNaN(scale)) overworldHeight.noise_params = [depth, scale];
			            }
			            if (Object.keys(overworldHeight).length > 0) components['minecraft:overworld_height'] = overworldHeight;
			        }
			        if (document.getElementById('enable_partially_frozen').checked) {
			            components['minecraft:partially_frozen'] = {};
			        }
			        if (document.getElementById('enable_replace_biomes').checked) {
			            const replacements = [];
			            document.querySelectorAll('#replacements_list_container > .dynamic-item').forEach(item => {
			                const dimensionObj = item.querySelector('input[name*="dimension"]:checked');
const dimension = dimensionObj ? dimensionObj.value : "minecraft:overworld";

			                const amount = parseFloat(item.querySelector('input[id$="amount"]').value);
			                const scale = parseFloat(item.querySelector('input[id$="noise_freq_scale"]').value);
			                const targets = Array.from(item.querySelector('select[id$="targets_select"]').selectedOptions).map(o => o.value);
			                
			                if (dimension && !isNaN(amount) && !isNaN(scale) && targets.length > 0) {
			                    replacements.push({
			                        dimension: dimension,
			                        amount: amount,
			                        noise_frequency_scale: scale,
			                        targets: targets
			                    });
			                }
			            });
			            
			            if (replacements.length > 0) {
			                components['minecraft:replace_biomes'] = {
			                    replacements: replacements
			                };
			            }
			        }
			        if (document.getElementById('enable_surface_builder').checked) {
			            const builderType = document.getElementById('surface_builder_type_select').value;
			            if (builderType) {
			                const builder = { type: builderType };
			                const getSpec = (name) => {
			                    const container = document.querySelector(`#surface_builder_dynamic_fields .form-group:has(#sb_${name}_name)`);
			                    return container ? getBlockSpecifierFromGroup(container) : null;
			                };
			                const getMultiSpec = (name) => {
			                    const specs = [];
			                    document.querySelectorAll(`#sb_${name}_list_container > .dynamic-item`).forEach(item => {
			                        const spec = getBlockSpecifierFromGroup(item);
			                        if (spec) specs.push(spec);
			                    });
			                    return specs;
			                };
			                switch (builderType) {
			                    case "minecraft:overworld":
			                    case "minecraft:frozen_ocean":
			                    case "minecraft:swamp":
			                        const depth = parseInt(document.getElementById('sb_sea_floor_depth')?.value);
			                        if (!isNaN(depth)) builder.sea_floor_depth = depth;
			                        ['sea_floor_material', 'foundation_material', 'mid_material', 'top_material', 'sea_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        if (builderType === "minecraft:swamp") {
			                            const puddleDepth = parseInt(document.getElementById('sb_max_puddle_depth_below_sea_level')?.value);
			                            if (!isNaN(puddleDepth)) builder.max_puddle_depth_below_sea_level = puddleDepth;
			                        }
			                        break;
			                    case "minecraft:mesa":
			                        const mesaDepth = parseInt(document.getElementById('sb_sea_floor_depth')?.value);
			                        if (!isNaN(mesaDepth)) builder.sea_floor_depth = mesaDepth;
			                        ['sea_floor_material', 'foundation_material', 'mid_material', 'top_material', 'sea_material', 'clay_material', 'hard_clay_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        builder.bryce_pillars = document.getElementById('sb_bryce_pillars')?.checked || false;
			                        builder.has_forest = document.getElementById('sb_has_forest')?.checked || false;
			                        break;
			                    case "minecraft:capped":
			                        const beachSpec = getSpec('beach_material');
			                        if (beachSpec) builder.beach_material = beachSpec;
			                        const ceilingSpecs = getMultiSpec('ceiling_materials');
			                        if (ceilingSpecs.length > 0) builder.ceiling_materials = ceilingSpecs;
			                        const floorSpecs = getMultiSpec('floor_materials');
			                        if (floorSpecs.length > 0) builder.floor_materials = floorSpecs;
			                        ['foundation_material', 'sea_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        break;
			                }
			                components['minecraft:surface_builder'] = { builder: builder };
			            }
			        }
			        if (document.getElementById('enable_surface_material_adjustments').checked) {
			            const adjustments = [];
			            document.querySelectorAll('#material_adjustments_container > .dynamic-item').forEach(item => {
			                const uniqueId = item.querySelector('input[id$="noise_min"]').id.replace('noise_min', '');
			                const adjustment = {};
			                const noiseMin = parseFloat(item.querySelector('input[id$="noise_min"]').value);
			                const noiseMax = parseFloat(item.querySelector('input[id$="noise_max"]').value);
			                if (!isNaN(noiseMin) && !isNaN(noiseMax)) adjustment.noise_range = [noiseMin, noiseMax];
			                const heightMin = item.querySelector('input[id$="height_min"]').value.trim();
			                const heightMax = item.querySelector('input[id$="height_max"]').value.trim();
			                if (heightMin && heightMax) adjustment.height_range = [heightMin, heightMax];
			                const scale = parseFloat(item.querySelector('input[id$="noise_freq_scale"]').value);
			                if (!isNaN(scale)) adjustment.noise_frequency_scale = scale;
			                const materials = {};
			                ['top_material', 'foundation_material', 'mid_material', 'sea_floor_material', 'sea_material'].forEach(type => {
			                    const enableToggle = item.querySelector(`#${uniqueId}enable_${type}`);
			                    if (enableToggle && enableToggle.checked) {
			                        const container = item.querySelector(`#${uniqueId}${type}_container`);
			                        const spec = container ? getBlockSpecifierFromGroup(container) : null;
			                        if (spec) materials[type] = spec;
			                    }
			                });
			                if (Object.keys(materials).length > 0) adjustment.materials = materials;
			                if (Object.keys(adjustment).length > 0) adjustments.push(adjustment);
			            });
			            if (adjustments.length > 0) components['minecraft:surface_material_adjustments'] = { adjustments: adjustments };
			        }
			        if (document.getElementById('enable_tags').checked) {
			                    // --- TAGS COMPONENT FIX ---
        // 1. Get Manual Custom Tags (safely)
        const manualTags = (typeof customTags !== 'undefined') ? Array.from(customTags) : [];
        
        // 2. Get Decorative Preset Tags (from the new system)
        const presetTags = (typeof window.getDecorationTags === 'function') ? window.getDecorationTags() : [];
        
        // 3. Get Predefined Tags (from dropdown)
        const isTagsEnabled = document.getElementById('enable_tags').checked;
        const predefinedTags = isTagsEnabled 
            ? Array.from(document.getElementById('biome_tags_select').selectedOptions).map(o => o.value)
            : [];

        // 4. Merge All Tags
        // We combine them if "Tags" is enabled OR if we have preset tags to add
        if (isTagsEnabled || presetTags.length > 0) {
            const allTags = [...new Set([...predefinedTags, ...manualTags, ...presetTags])].sort();
            
            if (allTags.length > 0) {
                components['minecraft:tags'] = { tags: allTags };
            }
        }

			        }
			        return biomeJson;
			    }
			
			    _initializeForm = function() {
			        setupCollapsibleSections();
			        populateBiomeTags();
			        ['hills_transformation_select', 'mutate_transformation_select', 'river_transformation_select', 'shore_transformation_select'].forEach(populateBiomeSelect);
			        
			        document.querySelectorAll('input[required], select[required], textarea[required]').forEach(el => {
			            if (el.closest('.component-content') || el.closest('.optional-input-content') || el.closest('.dynamic-item')) {
			                 el.dataset.originalRequired = 'true';
			            }
			        });
			
			        createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
			
			        updateColorInputUI(document.getElementById('map_tints_foliage_color_input'), document.getElementById('map_tints_foliage_color_picker'), '#6A7039');
			        document.getElementById('map_tints_foliage_group').style.display = document.getElementById('enable_map_tints_foliage').checked ? 'block' : 'none';
        // ... existing map_tints updateColorInputUI calls ...

        // --- ADDED: Client Biome Color Sync ---
        updateColorInputUI(document.getElementById('sky_color_hex_text'), document.getElementById('sky_color_hex'), '#88AAFF');
        updateColorInputUI(document.getElementById('water_surface_color_text'), document.getElementById('water_surface_color'), '#4455FF');
        updateColorInputUI(document.getElementById('foliage_color_hex_text'), document.getElementById('foliage_color_hex'), '#55AA33');
        updateColorInputUI(document.getElementById('grass_color_hex_text'), document.getElementById('grass_color_hex'), '#77CC44');
        updateColorInputUI(document.getElementById('dry_foliage_hex_text'), document.getElementById('dry_foliage_hex'), '#AAAAAA');
        // ---------------------------------------


			        updateColorInputUI(document.getElementById('grass_custom_tint_color_input'), document.getElementById('grass_custom_tint_color_picker'), '#B6DB61');
			        document.getElementById('grass_custom_tint_group').style.display = document.getElementById('grass_tint_type_custom').checked ? 'block' : 'none';
			        
			        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
			            const simpleRadio = document.getElementById(`${transformType}_transform_type_simple`);
			            const weightedRadio = document.getElementById(`${transformType}_transform_type_weighted`);
			            const simpleGroup = document.getElementById(`${transformType}_transformation_simple_group`);
			            const weightedGroup = document.getElementById(`${transformType}_transformation_weighted_group`);
			            const toggleGroups = () => {
			                const isSimple = simpleRadio.checked;
			                simpleGroup.style.display = isSimple ? 'block' : 'none';
			                weightedGroup.style.display = !isSimple ? 'block' : 'none';
			                toggleRequiredFields(simpleGroup, isSimple);
			                toggleRequiredFields(weightedGroup, !isSimple);
			            };
			            simpleRadio.addEventListener('change', toggleGroups);
			            weightedRadio.addEventListener('change', toggleGroups);
			            toggleGroups();
			        });
			
			        document.getElementById('biomeForm').addEventListener('submit', function(event) {
			            event.preventDefault();
			            try {
			                const biomeJson = generateFullBiomeJson();
			                const jsonOutputDiv = document.getElementById('jsonOutput');
			                jsonOutputDiv.textContent = JSON.stringify(biomeJson, null, 2);
			                
			                        // Automatically expand the Server Biome section
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'block';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');
        // --- END ADD ---
			            } catch (error) {
    console.error("JSON Generation Error:", error);
    // --- ADDED ERROR MODAL ---
    showModal({
        title: 'Validation Error', 
        message: error.message || error, 
        onConfirm: ()=>{}
    });
}

			            
			            
			        });
			
			        document.getElementById('copyJsonButton').addEventListener('click', function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            const tempTextArea = document.createElement('textarea');
			            tempTextArea.value = jsonOutput;
			            document.body.appendChild(tempTextArea);
			            tempTextArea.select();
			            try {
			                document.execCommand('copy');
			                showSnackbar('JSON copied to clipboard!');
			            } catch (err) {
			                console.error('Failed to copy JSON: ', err);
			                showModal({title: 'Copy Failed', message: 'Failed to copy JSON. Please copy manually.', onConfirm: ()=>{}});
			            } finally {
			                document.body.removeChild(tempTextArea);
			            }
			        });
			
			        document.getElementById('downloadJsonButton').addEventListener('click', function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            let biomeNameForFile = document.getElementById('identifier').value.trim().split(':').pop() || 'biome';
			            biomeNameForFile = biomeNameForFile.replace(/[^a-z0-9._-]/g, '_').toLowerCase();
			            const filename = `${biomeNameForFile}.biome.json`;
			            const blob = new Blob([jsonOutput], { type: 'application/json' });
			            const url = URL.createObjectURL(blob);
			            const a = document.createElement('a');
			            a.href = url;
			            a.download = filename;
			            document.body.appendChild(a);
			            a.click();
			            document.body.removeChild(a);
			            URL.revokeObjectURL(url);
			        });
			
			        document.getElementById('downloadMcpackButton').addEventListener('click', async function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            const identifier = document.getElementById('identifier').value.trim();
			            if (!jsonOutput.trim() || !identifier) {
			                showModal({title: 'Error', message: 'Please generate JSON with a valid identifier first.', onConfirm: ()=>{}});
			                return;
			            }
			            const zip = new JSZip();
			            const packName = `Wanxian Pack-${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;
			            const manifestJson = {
			                "format_version": 2,
			                "header": { "name": packName, "description": "Generated by Wanxian.", "uuid": generateUuidv4(), "version": [1, 0, 0], "min_engine_version": [1, 21, 90] },
			                "modules": [{ "type": "data", "uuid": generateUuidv4(), "version": [1, 0, 0] }]
			            };
			            try {
			                const response = await fetch('icons/icon3.png');
			                if (response.ok) zip.file("pack_icon.png", await response.blob());
			            } catch (e) { console.warn("Could not fetch pack icon.", e); }
			            zip.file("manifest.json", JSON.stringify(manifestJson, null, 2));
			            let biomeFilename = identifier.split(':').pop().replace(/[^a-z0-9._-]/g, '_').toLowerCase() + '.biome.json';
			            zip.file(`biomes/${biomeFilename}`, jsonOutput);
			            try {
			                const content = await zip.generateAsync({ type: "blob" });
			                const a = document.createElement('a');
			                a.href = URL.createObjectURL(content);
			                a.download = `${packName.replace(/ /g, '_').toLowerCase()}.mcpack`;
			                document.body.appendChild(a);
			                a.click();
			                document.body.removeChild(a);
			                URL.revokeObjectURL(a.href);
			                showSnackbar(`Successfully exported "${a.download}"!`);
			            } catch (error) {
			                showModal({title: 'Export Error', message: `Failed to create .mcpack: ${error.message}`, onConfirm: ()=>{}});
			            }
			        });
			
			
			
			        document.getElementById('importJsonButton').addEventListener('click', () => document.getElementById('importJsonFile').click());
    // --- Universal Import Logic ---
    document.getElementById('importJsonFile').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const jsonContent = JSON.parse(e.target.result);
                let loaded = false;

                // 1. Try Loading Server Biome
                if (jsonContent['minecraft:biome']) {
                    _populateFormFromJson(jsonContent);
                    loaded = true;
                }

                // 2. Try Loading Client Biome
                if (jsonContent['minecraft:client_biome']) {
                    // Enable the section first
                    const clientBox = document.getElementById('enable_clientbiomes');
                    clientBox.checked = true;
                    clientBox.dispatchEvent(new Event('change')); // Trigger UI update
                    
                    populateClientForm(jsonContent);
                    loaded = true;
                }

                if (loaded) {
                    showSnackbar('File imported successfully!');
                } else {
                    showModal({title: 'Import Error', message: 'JSON does not appear to be a valid Server or Client biome file.', onConfirm: ()=>{}});
                }

            } catch (error) {
                showModal({title: 'JSON Parse Error', message: `Error parsing file: ${error.message}`, onConfirm: ()=>{}});
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    });

			
			        document.getElementById('refreshButton').addEventListener('click', () => {
			            resetForm();
			            showSnackbar('Form values reset!');
			        });
			
			        document.querySelectorAll('.button').forEach(button => {
			            button.addEventListener('click', function(e) {
			                const ripple = document.createElement('span');
			                ripple.classList.add('ripple');
			                const rect = button.getBoundingClientRect();
			                const size = Math.max(rect.width, rect.height);
			                ripple.style.width = ripple.style.height = `${size}px`;
			                ripple.style.left = `${e.clientX - rect.left - (size / 2)}px`;
			                ripple.style.top = `${e.clientY - rect.top - (size / 2)}px`;
			                this.appendChild(ripple);
			                ripple.addEventListener('animationend', () => ripple.remove());
			            });
			        });
			        
			         document.querySelectorAll('input[name="height_config_type"]').forEach(radio => {
			            radio.addEventListener('change', function() {
			                const noiseTypeGroup = document.getElementById('height_noise_type_group');
			                const noiseParamsGroup = document.getElementById('height_noise_params_group');
			                const isNoiseType = this.value === 'noise_type';
			                noiseTypeGroup.style.display = isNoiseType ? 'block' : 'none';
			                noiseParamsGroup.style.display = !isNoiseType ? 'block' : 'none';
			                toggleRequiredFields(noiseTypeGroup, isNoiseType);
			                toggleRequiredFields(noiseParamsGroup, !isNoiseType);
			            });
			        });
			
			        document.getElementById('surface_builder_type_select').addEventListener('change', function() {
			            renderSurfaceBuilderFields(this.value);
			        });
			
			        document.querySelectorAll('input[name="grass_tint_type"]').forEach(radio => {
			            radio.addEventListener('change', function() {
			                const customTintGroup = document.getElementById('grass_custom_tint_group');
			                const isCustom = this.value === 'tint';
			                customTintGroup.style.display = isCustom ? 'block' : 'none';
			                toggleRequiredFields(customTintGroup, isCustom);
			            });
			        });
			
			        document.getElementById('enable_map_tints_foliage').addEventListener('change', function() {
			            document.getElementById('map_tints_foliage_group').style.display = this.checked ? 'block' : 'none';
			        });
			        
			        document.getElementById('enable_steep_material_adjustment').addEventListener('change', function() {
			             document.getElementById('steep_material_adjustment_group').style.display = this.checked ? 'block' : 'none';
			        });
			
			        document.getElementById('add_climate_category').addEventListener('click', () => addClimateCategoryEntry());
			        document.getElementById('add_material_adjustment').addEventListener('click', () => addMaterialAdjustmentEntry());
			        document.getElementById('add_custom_tag_button').addEventListener('click', () => addCustomTag());
			        document.getElementById('add_hills_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('hills_weighted_biomes_container'));
			        document.getElementById('add_mutate_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('mutate_weighted_biomes_container'));
			        document.getElementById('add_river_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('river_weighted_biomes_container'));
			        document.getElementById('add_shore_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('shore_weighted_biomes_container'));
			        
			        document.getElementById('add_replacement_button').addEventListener('click', () => addReplacementEntry());
			    };
			})();
		</script>
		<script src="suggestions.js"></script>
		<script>
			/**
			 * Attaches suggestion logic to a single input element.
			 * @param {HTMLInputElement} input The input element to attach the logic to.
			 */
			function attachSuggestionLogic(input) {
			    if (input.dataset.hasSuggestions) {
			        return; // Avoid duplicate setup
			    }
			    input.dataset.hasSuggestions = "true";
			
			    let suggestionBox;
			
			    /**
			     * Creates and initializes the suggestion box element if it doesn't exist.
			     * @returns {HTMLElement} The suggestion box element.
			     */
			    function getOrCreateSuggestionBox() {
			        if (!suggestionBox) {
			            suggestionBox = document.createElement("div");
			            suggestionBox.className = "suggestions";
			            document.body.appendChild(suggestionBox);
			        }
			        return suggestionBox;
			    }
			
			    /**
			     * Positions the suggestion box relative to the input element.
			     * @param {HTMLInputElement} targetInput The input element to position the box against.
			     */
			    function positionSuggestionBox(targetInput) {
			        const rect = targetInput.getBoundingClientRect();
			        suggestionBox.style.left = `${rect.left + window.scrollX}px`;
			        suggestionBox.style.top = `${rect.bottom + window.scrollY + 8}px`; // Add a small margin
			        suggestionBox.style.width = `${rect.width}px`;
			    }
			
			    /**
			     * Hides the suggestion box.
			     */
			    function hideSuggestions() {
			        if (suggestionBox) {
			            suggestionBox.style.display = "none";
			        }
			    }
			
			    // Handle user input
			    input.addEventListener("input", function() {
			        const value = this.value.toLowerCase();
			        // Assuming `window.defaultSuggestions` is a globally available array of strings.
			        const filtered = window.defaultSuggestions.filter(item => item.toLowerCase().includes(value));
			
			        const box = getOrCreateSuggestionBox();
			        positionSuggestionBox(this);
			        box.innerHTML = "";
			
			        if (filtered.length === 0 || !value) {
			            hideSuggestions();
			            return;
			        }
			
			        filtered.forEach(name => {
			            const option = document.createElement("div");
			            option.textContent = name;
			            option.className = "suggestion-item";
			            option.addEventListener("click", () => {
			                input.value = name;
			                hideSuggestions();
			            });
			            box.appendChild(option);
			        });
			
			        box.style.display = "block";
			    });
			
			    // Hide suggestions when the input loses focus, with a slight delay
			    // to allow clicks on the suggestion box itself.
			    input.addEventListener("blur", () => {
			        setTimeout(hideSuggestions, 150);
			    });
			}
			
			/**
			 * Initializes the suggestion system by attaching logic to all existing text inputs
			 * and observing for new inputs added to the DOM.
			 */
			function initSuggestionSystem() {
			    // Attach to all existing text inputs on the page
			    document.querySelectorAll('input[type="text"]').forEach(attachSuggestionLogic);
			
			    // Use a MutationObserver to watch for new text inputs being added dynamically
			    const observer = new MutationObserver(mutations => {
			        for (const mutation of mutations) {
			            mutation.addedNodes.forEach(node => {
			                if (node.tagName === "INPUT" && node.type === "text") {
			                    attachSuggestionLogic(node);
			                } else if (node.querySelectorAll) {
			                    node.querySelectorAll('input[type="text"]').forEach(attachSuggestionLogic);
			                }
			            });
			        }
			    });
			
			    // Start observing the document body for changes
			    observer.observe(document.body, {
			        childList: true,
			        subtree: true
			    });
			}
			
			// Initialize the system once the DOM is fully loaded
			document.addEventListener("DOMContentLoaded", initSuggestionSystem);
			
			// --- You'll need to define `window.defaultSuggestions` somewhere in your project. Example: ---
			// window.defaultSuggestions = ["Material Design", "Expressive", "Components", "Buttons", "Inputs", "Theme"];
		</script>

		<script src="app.js">app.js</script>
		<div class="fab-container">
			<button class="m3-icon-toggle" id="generateBtn">
			<span class="material-symbols-rounded">robot</span>
			</button>
			<button class="m3-icon-toggle" id="manageBtn" data-drawer="manageSheet">
			<span class="material-symbols-rounded">files</span>
			</button>
		</div>
		<div class="bottom-sheet" id="generateSheet">
    <div class="drag-handle-container">
        <div class="drag-handle" data-drawer="generateSheet"></div>
    </div>

    <div class="bottom-sheet-content">
<button type="button" class="generate-code-button button" id="downloadMcaddonButton" style="width: 100%; margin-top: 10px; padding: 26px;">
    <span class="material-symbols-rounded">inventory_2</span>
    Download .mcaddon (BP + RP)
</button>

        <div class="component-section start">
            <h3 class="collapsible-header" data-target="server-biome-content">
                <span class="component-title">Biome (Server)</span>
                <span class="material-symbols-rounded"></span>
            </h3>
            <div id="server-biome-content" class="component-content">
                <div class="menu-divider"></div>
                <div class="tool-container" style="margin-top: 15px; margin-bottom: 15px;">
                    
                    <div class="tool-management">
                        <!-- ADDED: Server Import Button -->
<input type="file" id="importServerJsonFile" accept=".json" style="display: none;">
<button type="button" id="importServerJsonBtn" class="copy-button" title="Import Server JSON">
    <span class="material-symbols-rounded">file_open</span>
</button>
<!-- END ADDED -->

                        <button type="button" class="copy-button" id="copyJsonButton">
    <span class="material-symbols-rounded">content_copy</span>
</button>
<button type="button" class="download-button" id="downloadJsonButton">
    <span class="material-symbols-rounded">download</span>
</button>
<button type="button" class="download-button" id="downloadMcpackButton">
    <span class="material-symbols-rounded">archive</span>
</button>

                    </div>
                </div>
                <pre id="jsonOutput" class="json-output" style="margin-top: 0;
                height: 250px;
                overflow: auto;"></pre>
            </div>
        </div>

        <div class="component-section end">
            <h3 class="collapsible-header" data-target="client-biome-content">
                <span class="component-title">Client Biome</span>
                <span class="material-symbols-rounded"></span>
            </h3>
            <div id="client-biome-content" class="component-content">
                <div class="menu-divider"></div>
                
                <div id="validation"></div>
                <div class="tool-container" style="margin-top: 15px; margin-bottom: 15px;">
                    <div class="tool-management">
                    	<input type="file" id="importClientJsonFile" accept=".json" style="display: none;">
<button type="button" id="importClientJsonBtn" class="copy-button" title="Import Client JSON">
    <span class="material-symbols-rounded">file_open</span>
</button>
                        <button type="button" id="copyBtn" class="copy-button">
                            <span class="material-symbols-rounded">content_copy</span>
                        </button>
                        <button type="button" id="downloadBtn" class="download-button">
                            <span class="material-symbols-rounded">download</span></button>
                        <button type="button" id="downloadClientMcpackButton" class="download-button">
                            <span class="material-symbols-rounded">archive</span>
                        </button>
                        </div>
                </div>
<pre id="outputJson" class="json-output" style="margin-top: 0;
height: 250px; overflow: auto;"></pre>




                


                    </div>
                </div>
            </div>
        </div>

    </div> </div>

		<div class="bottom-sheet" id="manageSheet">
			<div class="drag-handle-container">
				<div class="drag-handle" data-drawer="manageSheet"></div>
			</div>
			<div class="bottom-sheet-content">
				<!-- Preset Management Section -->

				<div class="tool-container" style="padding: 16px; text-align: center;">
    <span class="material-symbols-rounded" 
          style="font-size: 40px; 
                 color: var(--md-sys-color-primary); 
                 font-variation-settings: 'FILL' 1;">
        folder_open
    </span>
</div>
<h2 style="justify-content: center; display: flex;">Manage presets</h2>
				<div class="tool-container">
				    
					<div class="tool-management select">
						
						<label for="presetLoadSelect">Select a preset:</label>
						<select id="presetLoadSelect">
							<option value="">-- No Presets Found --</option>
						</select>
					</div>
				</div>
				<div class="tool-container" >
					<div class="tool-management">
						<button type="button" class="copy-button add-button" id="loadPresetButton">
							<span class="material-symbols-rounded">input</span>
							<div></div>
						</button>
						<button type="button" class="copy-button add-button" id="savePresetButton">
						<span class="material-symbols-rounded">save</span>
						</button>
						<button type="button" class="download-button remove-button" id="deletePresetButton">
						<span class="material-symbols-rounded">delete</span>
						</button>
						<button type="button" class="download-button" id="exportMultipleButton">
						<span class="material-symbols-rounded">collections</span>
						</button>
					</div>
				</div>
			</div>
		</div>
<script>
    const allSheets = [document.getElementById("generateSheet"), document.getElementById("manageSheet")];
    const allButtons = [document.getElementById("generateBtn"), document.getElementById("manageBtn")];
    const draggableSheets = document.querySelectorAll('.bottom-sheet');
    
    let startY = 0;
    let currentSheet = null;
    let isDraggingSheet = false;
    let isGestureLockedToContent = false; // New flag to lock scroll mode
    const TRANSITION_STYLE = 'transform 0.4s cubic-bezier(0.25, 0.1, 0.25, 1.0)';
    
    // --- Core Toggle Logic ---
    function closeAllSheets() {
      allSheets.forEach(sheet => {
        if (sheet) {
          sheet.classList.remove("active");
          sheet.style.transform = 'translateY(100%)'; 
          sheet.style.cursor = '';
        }
      });
      allButtons.forEach(btn => btn.classList.remove("active"));
    }
    
    function handleToggle(clickedButton, associatedSheet) {
        const isActive = clickedButton.classList.contains("active");
        closeAllSheets(); 
        if (!isActive) {
            associatedSheet.style.transform = 'translateY(0)'; 
            clickedButton.classList.add("active");
            associatedSheet.classList.add("active");
        }
    }
    
    allButtons.forEach(button => {
        button.addEventListener("click", (e) => {
            e.preventDefault();
            handleToggle(button, document.getElementById(button.getAttribute('data-drawer')));
        });
    });

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".bottom-sheet") && !e.target.closest(".fab-container")) {
        closeAllSheets();
      }
    });
    
    // --- SMART DRAG FUNCTIONALITY (SCROLL LOCK FIX) ---
    
    // Helper: Checks if the target element OR any of its parents are currently scrolled down.
    function isAnyAncestorScrolled(target) {
        let el = target;
        while (el && el !== currentSheet && !el.classList.contains('bottom-sheet')) {
            if (el.scrollTop > 0) {
                return true;
            }
            el = el.parentElement;
        }
        return false;
    }

    function cleanupListeners() {
        document.removeEventListener('mousemove', dragMove);
        document.removeEventListener('touchmove', dragMove);
        document.removeEventListener('mouseup', dragEnd);
        document.removeEventListener('touchend', dragEnd);
        currentSheet = null; 
        isDraggingSheet = false;
        // Do not reset isGestureLockedToContent here, it resets on next dragStart
    }
    
    function dragStart(e) {
        const target = e.target.closest('.bottom-sheet');
        if (!target || !target.classList.contains('active')) return;

        if (e.target.closest('input[type="range"], .slider, button, .switch, input, select')) {
            return;
        }

        // 1. STATE LOCK:
        // If we start the gesture on content that is scrolled down, we LOCK this gesture 
        // to "content scrolling mode". We will NOT allow the sheet to drag close 
        // during this specific swipe, even if it hits the top.
        if (isAnyAncestorScrolled(e.target)) {
            isGestureLockedToContent = true;
        } else {
            isGestureLockedToContent = false;
        }

        currentSheet = target;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        isDraggingSheet = true;
        currentSheet.style.transition = 'none';
        
        document.addEventListener('mousemove', dragMove);
        document.addEventListener('touchmove', dragMove, { passive: false });
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('touchend', dragEnd);
    }
    
    function dragMove(e) {
        if (!currentSheet || !isDraggingSheet) return;
    
        // 2. CHECK LOCK:
        // If we locked this gesture to content scrolling earlier, stop here.
        // This lets the browser handle the scroll naturally without moving the sheet.
        if (isGestureLockedToContent) {
            return; 
        }

        const currentY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaY = currentY - startY;
        
        // 3. Direction Check:
        // If moving UP (scrolling down), let browser handle it.
        if (deltaY < 0) {
            return;
        }

        // 4. Dynamic Check (Edge Case):
        // If we started at 0, scrolled down, and are now back at 0...
        // We double check if content is scrolled to avoid yanking.
        if (isAnyAncestorScrolled(e.target)) {
            return;
        }

        // If we passed all checks, we are dragging the sheet down.
        if (e.cancelable) e.preventDefault(); 

        if(deltaY > 0) currentSheet.style.cursor = 'grabbing';
        
        let transformY = deltaY;
        if (transformY < 0) transformY = 0;

        currentSheet.style.transform = `translateY(${transformY}px)`;
    }
    
    function dragEnd(e) {
        if (!currentSheet) {
            cleanupListeners();
            return;
        }
        
        const sheetToClose = currentSheet;
        sheetToClose.style.transition = TRANSITION_STYLE;
    
        const finalY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const deltaY = finalY - startY;
        
        // Close if dragged down significantly AND we weren't locked to content
        if (!isGestureLockedToContent && deltaY > 100) {
            sheetToClose.style.transform = 'translateY(100%)'; 
            setTimeout(() => closeAllSheets(), 400); 
        } else {
            sheetToClose.style.transform = 'translateY(0)';
        }
    
        cleanupListeners();
    }
    
    draggableSheets.forEach(sheet => {
        sheet.addEventListener('mousedown', dragStart);
        sheet.addEventListener('touchstart', dragStart, { passive: false }); 
    });
</script>



		<script>
			const biomeForm = document.getElementById('biomeForm');
			const generateBtn = document.getElementById('generateBtn');
			const formSubmitBtn = document.getElementById('formSubmitBtn');
			
			let triggeredBy = null; // prevent recursion
			
			// shared logic for generation
			function handleBiomeGeneration() {
			  // _generateJson();  // your real generation logic
			}
			
			// when the form submits
			biomeForm.addEventListener('submit', (e) => {
			  e.preventDefault();
			  
			  if (!biomeForm.checkValidity()) {
			    biomeForm.reportValidity(); // show validation UI if invalid
			    return;
			  }
			  
			  if (triggeredBy === 'generateBtn') {
			    triggeredBy = null;
			    handleBiomeGeneration(); // run generation logic only once
			    return;
			  }
			  
			  // if submit button triggered the submit
			  triggeredBy = 'formSubmit';
			  generateBtn.click(); // simulate pressing Generate
			  triggeredBy = null;
			});
			
			// when clicking the Generate button
			generateBtn.addEventListener('click', () => {
			  if (triggeredBy === 'formSubmit') return; // avoid recursion
			  
			  // check required fields before submit
			  if (!biomeForm.checkValidity()) {
			    biomeForm.reportValidity(); // show built-in popup
			    return; // don't submit or trigger anything
			  }
			  
			  triggeredBy = 'generateBtn';
			  biomeForm.requestSubmit(); // valid → trigger form submit event
			  triggeredBy = null;
			});
		</script>
		<script>
			const moreButton = document.getElementById('more-button');
			const dropdownMenu = document.getElementById('dropdown-menu');
			const themeToggleLink = document.getElementById('theme-toggle');
			const themeToggleButton = themeToggleLink.querySelector('.trailing-icon-button');
			const aboutButton = document.getElementById('about-button');
			const aboutDialogBackdrop = document.getElementById('about-dialog-backdrop');
			const closeAboutButton = document.getElementById('close-about-button');
			
			
			// --- THEME LOGIC ---
			
			function updateThemeIcon(isDark) {
			    const icon = themeToggleButton.querySelector('.material-symbols-rounded');
			    icon.textContent = isDark ? 'toggle_on' : 'toggle_off';
			    icon.style.color = isDark ? 'var(--md-sys-color-primary)' : 'var(--md-sys-color-on-surface-variant)';
			    themeToggleButton.setAttribute('data-toggled', isDark ? 'on' : 'off');
			}
			
			function toggleDarkTheme(forceDark = null) {
			    const isDark = forceDark !== null ? forceDark : !document.documentElement.classList.contains('dark-theme');
			    document.documentElement.classList.toggle('dark-theme', isDark);
			    updateThemeIcon(isDark);
			    
			    // Persist the user's choice (optional, but good practice)
			    localStorage.setItem('theme', isDark ? 'dark' : 'light');
			}
			
			// Initialize theme based on system preference or saved choice
			function initializeTheme() {
			    const savedTheme = localStorage.getItem('theme');
			    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
			    
			    if (savedTheme === 'dark' || (savedTheme === null && systemPrefersDark)) {
			        toggleDarkTheme(true);
			    } else {
			        toggleDarkTheme(false);
			    }
			}
			
			// Run theme initialization
			initializeTheme();
			
			// --- EVENT LISTENERS ---
			
			// Dropdown toggle
			moreButton.addEventListener('click', (e) => {
			    e.stopPropagation();
			    dropdownMenu.classList.toggle('visible');
			});
			
			// Close dropdown when clicking outside
			document.addEventListener('click', (event) => {
			    if (!moreButton.contains(event.target) && !dropdownMenu.contains(event.target) && !aboutDialogBackdrop.contains(event.target)) {
			        dropdownMenu.classList.remove('visible');
			    }
			});
			
			// Theme Toggle Click Handler
			themeToggleLink.addEventListener('click', (e) => {
			    e.preventDefault();
			    e.stopPropagation(); 
			    toggleDarkTheme();
			});
			
			// About Dialog Handlers
			aboutButton.addEventListener('click', (e) => {
			    e.preventDefault();
			    dropdownMenu.classList.remove('visible');
			    aboutDialogBackdrop.classList.add('visible');
			});
			
			closeAboutButton.addEventListener('click', () => {
			    aboutDialogBackdrop.classList.remove('visible');
			});
			
			aboutDialogBackdrop.addEventListener('click', (e) => {
			    if (e.target === aboutDialogBackdrop) {
			        aboutDialogBackdrop.classList.remove('visible');
			    }
			});
			
			
    // --- Server Sheet Import Listeners ---
    const importServerBtn = document.getElementById('importServerJsonBtn');
    const importServerFile = document.getElementById('importServerJsonFile');

    if(importServerBtn && importServerFile) {
        importServerBtn.addEventListener('click', () => {
            importServerFile.click();
        });

        importServerFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    if (json['minecraft:biome']) {
                        _populateFormFromJson(json);
                        // Also update the preview since we are in the sheet
                        document.getElementById('jsonOutput').textContent = JSON.stringify(json, null, 2);
                        showSnackbar("Server Biome Imported!");
                    } else {
                        alert("This file does not contain a 'minecraft:biome' definition.");
                    }
                } catch (err) {
                    alert("Invalid JSON file.");
                }
            };
            reader.readAsText(file);
            e.target.value = ''; 
        });
    }

		</script>
		<script>
			const fabContainer = document.querySelector('.fab-container');
			let lastScrollY = window.scrollY;
			let isHidden = false;
			let scrollTimeout;
			
			window.addEventListener('scroll', () => {
			  clearTimeout(scrollTimeout);
			
			  // hide when scrolling down
			  if (window.scrollY > lastScrollY && !isHidden) {
			    fabContainer.classList.add('hide');
			    isHidden = true;
			  }
			  // show when scrolling up
			  else if (window.scrollY < lastScrollY && isHidden) {
			    fabContainer.classList.remove('hide');
			    isHidden = false;
			  }
			
			  lastScrollY = window.scrollY;
			
			  // if scroll stops, show again after short delay
			  
			});
		</script>
		<script>
			const box = document.getElementById('enable_clientbiomes');
			// --- Function to read query parameter ---
			function getQueryParam(name) {
			  const params = new URLSearchParams(window.location.search);
			  return params.get(name);
			}
			// --- Initialize checkbox based on query ---
			function initCheckbox() {
			  const state = getQueryParam('clientbiomes');
			  if (state === 'on') box.checked = true;
			  else if (state === 'off') box.checked = false;
			}
			// --- Update query parameter when checkbox changes ---
			function updateQuery() {
			  const params = new URLSearchParams(window.location.search);
			  params.set('clientbiomes', box.checked ? 'on' : 'off');
			  const newUrl = `${window.location.pathname}?${params.toString()}`;
			  history.replaceState({}, '', newUrl);
			}
			box.addEventListener('change', updateQuery);
			// --- Run once on page load ---
			initCheckbox();
		</script>
		<script>
			const btn = document.getElementById('fullscreenBtn');
			
			btn.addEventListener('click', async () => {
			  if (!document.fullscreenElement) {
			    await document.documentElement.requestFullscreen();
			  } else {
			    await document.exitFullscreen();
			  }
			});
			
			
		</script>
		<script>
			/* Utilities */
			const $ = id => document.getElementById(id);
			const show = (el) => el.style.display = '';
			const hide = (el) => el.style.display = 'none';
			
			/* Toggle controls */
/* Toggle controls */
[
  ['comp_sky_color','sky_controls'], // Note: 'sky_controls' usually refers to the ID of the content div if you named them that way, or use the logic below
  ['comp_sky_color','sky_color-content'], 
  ['comp_water_appearance','water_appearance-content'],
  ['comp_fog','fog_appearance-content'],
  ['comp_foliage','foliage_appearance-content'],
  ['comp_grass','grass_appearance-content'],
  ['comp_vibrant_visuals', 'vibrant_visuals-content'], // NEW
  ['comp_precip','precipitation-content'],
  ['comp_ambient','ambient_sounds-content'],
  ['comp_underwater_ambient','underwater_ambient_block'],
  ['comp_music','biome_music-content'],
  ['comp_dry_foliage','dry_foliage_color-content'],
].forEach(pair=>{
  const cb = $(pair[0]); const body = $(pair[1]);
  if(!cb || !body) return;
  // Initialize state based on checkbox
  if(cb.checked) show(body); else hide(body);
  
  cb.addEventListener('change', ()=> {
    if(cb.checked) show(body); else hide(body);
  });
});

			
			/* precipitation mode */
			$('precip_mode').addEventListener('change', (e)=>{
			  const mode = e.target.value;
			  if(mode === 'single'){ show($('precip_single')); hide($('precip_advanced')); }
			  else { hide($('precip_single')); show($('precip_advanced')); }
			});
			
			/* ambient underwater toggle (checkbox inside ambient section) */
			$('comp_underwater_ambient').addEventListener('change', (e)=>{
			  const el = $('underwater_ambient_block');
			  if(e.target.checked) show(el); else hide(el);
			});
			
			
			/* validation helper for identifier */
			function validateIdentifier(id){
			  // pattern from docs: ^[a-z0-9.%+\-]+:[a-z0-9.%+\-]+$
			  const re = /^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/;
			  return re.test(id);
			}
			
			/* Build the components object following docs */
			function buildComponents(){
			  const comps = {};
			
			  /* sky_color */
			  if($('comp_sky_color').checked){
			    const arrText = $('sky_color_arr').value.trim();
			    if(arrText){
			      try{ const arr = JSON.parse(arrText); if(Array.isArray(arr)) comps["minecraft:sky_color"] = { "sky_color": arr }; else throw 'not array'; }
			      catch(e){ throw "sky_color array must be valid JSON array e.g. [136,170,255]"; }
			    } else {
			      comps["minecraft:sky_color"] = { "sky_color": $('sky_color_hex').value };
			    }
			  }
			
			  /* water_appearance and water_identifier */
			  if($('comp_water_appearance').checked){
			    const obj = {};
			    const hex = $('water_surface_color').value;
			    if(hex) obj["surface_color"] = hex;
			    const opa = parseFloat($('water_surface_opacity').value);
			    if(!isNaN(opa)) obj["surface_opacity"] = opa;
			    if(Object.keys(obj).length) comps["minecraft:water_appearance"] = obj;
			  }
			
			  /* fog_appearance */
			  if($('comp_fog').checked){
			    const fid = $('fog_identifier').value.trim();
			    if(!fid) throw "fog_appearance: fog_identifier must be provided when enabled.";
			    comps["minecraft:fog_appearance"] = { "fog_identifier": fid };
			  }
			
			  /* foliage_appearance */
			  if($('comp_foliage').checked){
			    const map = $('foliage_color_map').value;
			    if(map){
			      comps["minecraft:foliage_appearance"] = { "color_map": map };
			    } else {
			      comps["minecraft:foliage_appearance"] = { "color": $('foliage_color_hex').value };
			    }
			  }
			
			  /* grass_appearance */
			  if($('comp_grass').checked){
			    const map = $('grass_color_map').value;
			    const obj = {};
			    if(map) obj["color_map"] = map;
			    else obj["color"] = $('grass_color_hex').value;
			    if($('grass_is_shaded').checked) obj["grass_is_shaded"] = true;
			    comps["minecraft:grass_appearance"] = obj;
			  }
			
			  /* dry_foliage_color */
			  if($('comp_dry_foliage').checked){
			    const arr = $('dry_foliage_array').value.trim();
			    if(arr){
			      try{ const parsed = JSON.parse(arr); if(Array.isArray(parsed)) comps["minecraft:dry_foliage_color"] = { "color": parsed }; else throw 'not array'; }
			      catch(e){ throw "dry_foliage_color: RGB array must be valid JSON array e.g. [170,170,170]"; }
			    } else {
			      comps["minecraft:dry_foliage_color"] = { "color": $('dry_foliage_hex').value };
			    }
			  }
			
			  /* vibrant visuals identifiers */
  /* Vibrant Visuals (Unified) */
  if($('comp_vibrant_visuals').checked){
    const atmo = $('vibrant_atmosphere').value.trim();
    if(atmo) comps["minecraft:atmosphere_identifier"] = { "atmosphere_identifier": atmo };

    const grade = $('vibrant_color_grading').value.trim();
    if(grade) comps["minecraft:color_grading_identifier"] = { "color_grading_identifier": grade };

    const cube = $('vibrant_cubemap').value.trim();
    if(cube) comps["minecraft:cubemap_identifier"] = { "cubemap_identifier": cube };

    const light = $('vibrant_lighting').value.trim();
    if(light) comps["minecraft:lighting_identifier"] = { "lighting_identifier": light };

    const water = $('vibrant_water').value.trim();
    if(water) comps["minecraft:water_identifier"] = { "water_identifier": water };
  }

			
			  /* precipitation */
			  if($('comp_precip').checked){
			    const mode = $('precip_mode').value;
			    if(mode === 'single'){
			      const type = $('precip_type').value;
			      const dens = $('precip_density').value.trim();
			      if(!type) throw "Precipitation: choose type (or disable precipitation).";
			      const d = dens === "" ? 0 : parseFloat(dens);
			      if(isNaN(d)) throw "Precipitation density must be a number.";
			      const obj = {}; obj[type] = d;
			      comps["minecraft:precipitation"] = obj;
			    } else {
			      // advanced multiple allowed
			      const obj = {};
			      const ash = parseFloat($('precip_ash').value) || 0;
			      const blue = parseFloat($('precip_blue_spores').value) || 0;
			      const red = parseFloat($('precip_red_spores').value) || 0;
			      const white = parseFloat($('precip_white_ash').value) || 0;
			      if(ash>0) obj["ash"]=ash;
			      if(blue>0) obj["blue_spores"]=blue;
			      if(red>0) obj["red_spores"]=red;
			      if(white>0) obj["white_ash"]=white;
			      if(Object.keys(obj).length === 0) throw "Precipitation (advanced): no densities set.";
			      comps["minecraft:precipitation"] = obj;
			    }
			  }
			
			  /* ambient sounds */
			// Replace your existing ambient-sounds block with this code
			if ($('comp_ambient').checked) {
			  const ambient = {};
			
			  // loop -> should be a string (identifier)
			  const loop = $('ambient_loop').value.trim();
			  if (loop) ambient["loop"] = loop;
			
			  // addition -> object { asset, chance }
			  const add_asset = $('ambient_add_asset').value.trim();
			  const add_chance = $('ambient_add_chance').value.trim();
			  if (add_asset) {
			    const chanceNum = add_chance === "" ? 1.0 : parseFloat(add_chance);
			    if (isNaN(chanceNum) || chanceNum < 0 || chanceNum > 1) throw "Ambient addition chance must be 0.0–1.0";
			    ambient["addition"] = { "asset": add_asset, "chance": chanceNum };
			  }
			
			  // mood -> should be a string (identifier)
			  const mood = $('ambient_mood').value.trim();
			  if (mood) ambient["mood"] = mood;
			
			  // Underwater variants
			  if ($('comp_underwater_ambient').checked) {
			    const ua = $('underwater_add_asset').value.trim();
			    const uc = $('underwater_add_chance').value.trim();
			    if (ua) {
			      const chanceNum = uc === "" ? 1.0 : parseFloat(uc);
			      if (isNaN(chanceNum) || chanceNum < 0 || chanceNum > 1) throw "Underwater addition chance must be 0.0–1.0";
			      ambient["underwater_addition"] = { "asset": ua, "chance": chanceNum };
			    }
			
			    // underwater_loop -> string
			    const ul = $('underwater_loop').value.trim();
			    if (ul) ambient["underwater_loop"] = ul;
			
			    // underwater_mood -> string
			    const um = $('underwater_mood').value.trim();
			    if (um) ambient["underwater_mood"] = um;
			  }
			
			  if (Object.keys(ambient).length) {
			    comps["minecraft:ambient_sounds"] = ambient;
			  }
			}
			
			  /* biome music */
			  if($('comp_music').checked){
			    const md = $('music_definition').value.trim();
			    const vm = parseFloat($('music_volume').value);
			    const um = $('music_underwater').value;
			    const obj = {};
			    if(md !== "") obj["music_definition"] = md;
			    if(!isNaN(vm)) obj["volume_multiplier"] = vm;
			    if(um === "true") obj["underwater_music"] = true;
			    else if(um === "false") obj["underwater_music"] = false;
			    comps["minecraft:biome_music"] = obj;
			  }
			
			  return comps;
			}
			
			/* generate button */
			$('generateBtn').addEventListener('click', () => {
    $('validation').style.display = 'none';
    $('validation').innerText = '';

    // --- REQUEST 2: Check Validity First ---
    const form = document.getElementById('biomeForm');
    if (!form.checkValidity()) {
        form.reportValidity(); // Shows browser native validation bubbles
        return; // STOP here. Do not open sheet.
    }
    // ---------------------------------------

    try {
        // 1. Generate Server Biome (Always happens)
        const identifier = $('identifier').value.trim().toLowerCase();
        const fv = $('format_version').value.trim();
        if (!validateIdentifier(identifier)) {
            throw "Identifier invalid. Use namespace:biome_name pattern (lowercase).";
        }
        
        // Use original value setter (no lowercase force) to keep user input style if desired, 
        // but validation forces format anyway.
        const components = buildComponents();
        const output = {
            "format_version": fv,
            "minecraft:client_biome": {
                "description": {
                    "identifier": identifier
                },
                "components": components
            }
        };

        const serverJson = generateFullBiomeJson(); // Generate server JSON
        $('jsonOutput').textContent = JSON.stringify(serverJson, null, 2);
        
        // Expand Server Section
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'block';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');

        // --- REQUEST 3: Handle Client Biome Toggle ---
        const clientEnabled = document.getElementById('enable_clientbiomes').checked;
        const clientContent = document.getElementById('client-biome-content');
        
        if (clientEnabled) {
            // Generate Client JSON only if enabled
            $('outputJson').textContent = JSON.stringify(output, null, 2);
            
            // Show Client Section
            clientContent.style.display = 'block';
            clientContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');
        } else {
            // Clear Client JSON
            $('outputJson').textContent = "";
            
            // Hide/Collapse Client Section
            clientContent.style.display = 'none';
            clientContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
        }
        // ---------------------------------------------

        // --- REQUEST 2: Open Sheet Manually on Success ---
        const sheet = document.getElementById('generateSheet');
        const btn = document.getElementById('generateBtn');
        // Use existing handleToggle logic from your app.js logic
        if (!sheet.classList.contains('active')) {
             handleToggle(btn, sheet);
        }
        // -------------------------------------------------

    } catch (err) {
        $('validation').style.display = 'block';
        $('validation').innerText = err.toString();
        // Scroll to validation error if needed, do not open sheet
    }
});

			
			/* download & copy handling */
			$('downloadBtn').addEventListener('click', ()=>{
			  const text = $('outputJson').textContent;
			  if(!text){ alert("Generate JSON first."); return; }
			  const blob = new Blob([text], {type:'application/json'});
			  const url = URL.createObjectURL(blob);
			  const a = document.createElement('a');
			  const fname = $('identifier').value.trim().replace(/[:]/g,'_') + "_client_biome.json";
			  a.href = url; a.download = fname; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
			});
			$('copyBtn').addEventListener('click', ()=>{
			  const text = $('outputJson').textContent;
			  if(!text){ alert("Generate JSON first."); return; }
			  navigator.clipboard.writeText(text).then(()=>{ alert("Copied JSON to clipboard"); }, ()=>{ alert("Copy failed"); });
			});
			// --- Client Import Event Listeners ---
$('importClientJsonBtn').addEventListener('click', () => {
    $('importClientJsonFile').click();
});

$('importClientJsonFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const json = JSON.parse(event.target.result);
            populateClientForm(json);
        } catch (err) {
            alert("Invalid JSON file.");
        }
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset so same file can be selected again
});

			
$('downloadClientMcpackButton').addEventListener('click', async () => {
    const jsonOutput = $('outputJson').textContent;
    const identifier = $('identifier').value.trim();

    if (!jsonOutput.trim() || !identifier) {
        alert('Please generate the client biome JSON first and ensure an identifier is set.');
        return;
    }

    if (!validateIdentifier(identifier)) {
        alert("Identifier invalid. Use namespace:biome_name pattern (lowercase).");
        return;
    }

    let clientBiomeData;
    try {
        clientBiomeData = JSON.parse(jsonOutput);
    } catch (e) {
        alert("Generated JSON is invalid. Please try generating again.");
        return;
    }

    // --- CHANGED LOGIC STARTS HERE ---

    // 1. Extract the name part from "namespace:name"
    const namePart = identifier.split(':')[1] || identifier; 
    // 2. Sanitize to ensure valid filename (replace special chars with underscore)
    const cleanName = namePart.replace(/[^a-z0-9._-]/g, '_').toLowerCase();
    // 3. Construct filename
    const fileName = `${cleanName}.client_biome.json`;
    



    const zip = new JSZip();
    const packName = `Wanxian Client Pack-${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;
    
        // Add Custom Fogs


    // Create a RESOURCE PACK manifest
    const manifestJson = {
        "format_version": 2,
        "header": {
            "name": packName,
            "description": "Client biome resource pack generated by Wanxian.",
            "uuid": generateUuidv4(),
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [
            {
                "type": "resources",
                "uuid": generateUuidv4(),
                "version": [1, 0, 0]
            }
        ]
    };

    // Add pack icon
    try {
        const response = await fetch('icons/icon3.png');
        if (response.ok) zip.file("pack_icon.png", await response.blob());
    } catch (e) {
        console.warn("Could not fetch pack icon.", e);
    }

    // Add manifest to root
    zip.file("manifest.json", JSON.stringify(manifestJson, null, 2));

    // 4. Create 'biomes' folder and add the file inside it
    const biomesFolder = zip.folder("biomes");
    biomesFolder.file(fileName, JSON.stringify(clientBiomeData, null, 2));

    // --- CHANGED LOGIC ENDS HERE ---

    // Generate and download the .mcpack
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName.replace(/ /g, '_').toLowerCase()}.mcpack`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        alert(`Successfully exported "${a.download}"!`);
    } catch (error) {
        alert(`Failed to create .mcpack: ${error.message}`);
    }
});


			
			/* basic keyboard shortcut: Ctrl+G to generate */
			document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='g'){ e.preventDefault(); $('generateBtn').click(); } });
			
			/* small UX: when user changes color, show swatches already done above */
			/* done earlier */
			
		</script>
				<script>
			document.addEventListener('DOMContentLoaded', () => {
			  const checkbox = document.getElementById('enable_clientbiomes');
			  const hiddenContainer = document.getElementById('hidden-container');
			
			  // Define the update logic
			  const updateVisibility = () => {
			    hiddenContainer.style.display = checkbox.checked ? 'block' : 'none';
			  };
			
			  // Listen for changes
			  checkbox.addEventListener('change', updateVisibility);
			  
			  // Run once immediately to handle the "clientbiomes=on" query param
			  updateVisibility();
			});
		</script>

		<script>
document.addEventListener('DOMContentLoaded', () => {
    // This function makes the new "Biome (Server)" and "Client Biome" headers clickable
    function setupSheetCollapsibles() {
        const sheet = document.getElementById('generateSheet');
        if (!sheet) return;

        // Find the specific headers inside the generateSheet
        sheet.querySelectorAll('.collapsible-header[data-target="server-biome-content"], .collapsible-header[data-target="client-biome-content"]')
            .forEach(header => {
                const contentId = header.dataset.target;
                const content = document.getElementById(contentId);

                if (content) {
                    // Start them as collapsed
                    content.style.display = 'none';
                    header.classList.add('collapsed');

                    // Add click event listener to the header itself
                    header.addEventListener('click', (event) => {
                        // Prevent clicks on any inner buttons from triggering collapse
                        if (event.target.closest('button, .switch, a')) {
                            return;
                        }
                        
                        const isCollapsed = content.style.display === 'none';
                        
                        content.style.display = isCollapsed ? 'block' : 'none';
                        header.classList.toggle('collapsed', !isCollapsed);
                    });
                }
            });
    }

    // Run this new setup function
    setupSheetCollapsibles();
});

// --- Client Biome Import Logic ---

function populateClientForm(data) {
    try {
        const root = data['minecraft:client_biome'];
        if (!root) throw new Error("Invalid Client Biome JSON: Missing 'minecraft:client_biome'");
        
        const desc = root.description;
        const comps = root.components;

        // 1. Set Identifier
        if (desc && desc.identifier) {
            $('identifier').value = desc.identifier;
        }

        // Helper to toggle switch and trigger change event (to show/hide sub-menus)
        const toggleComp = (id, state) => {
            const el = $(id);
            if (el) {
                el.checked = state;
                el.dispatchEvent(new Event('change'));
            }
        };

        // Helper to set value if exists
        const setVal = (id, val) => { if ($(id) && val !== undefined) $(id).value = val; };
        
        // Helper to set color (updates both picker and text)
        const setColor = (textId, pickerId, val) => {
            if (!val) return;
            if (typeof val === 'string') {
                setVal(textId, val);
                setVal(pickerId, val);
            } else if (Array.isArray(val)) {
                // If it's an RGB array, put it in the array input (if specific field exists) or text
                 // This depends on specific field logic, usually we just fill the array input
            }
        };

        if (!comps) return;

        // --- Sky Color ---
        if (comps['minecraft:sky_color']) {
            toggleComp('comp_sky_color', true);
            const sc = comps['minecraft:sky_color'].sky_color;
            if (Array.isArray(sc)) {
                setVal('sky_color_arr', JSON.stringify(sc));
            } else {
                setColor('sky_color_hex_text', 'sky_color_hex', sc);
            }
        } else toggleComp('comp_sky_color', false);

        // --- Water Appearance ---
        if (comps['minecraft:water_appearance']) {
            toggleComp('comp_water_appearance', true);
            const wa = comps['minecraft:water_appearance'];
            setColor('water_surface_color_text', 'water_surface_color', wa.surface_color);
            const el_opa = document.getElementById('water_surface_opacity');
if (wa.surface_opacity !== undefined) { 
    el_opa.value = wa.surface_opacity; 
    if (el_opa.updateSliderUI) el_opa.updateSliderUI(); // <-- NEW LINE for slider update
}

        } else toggleComp('comp_water_appearance', false);

        // --- Fog ---
        if (comps['minecraft:fog_appearance']) {
            toggleComp('comp_fog', true);
            setVal('fog_identifier', comps['minecraft:fog_appearance'].fog_identifier);
        } else toggleComp('comp_fog', false);

        // --- Foliage ---
        if (comps['minecraft:foliage_appearance']) {
            toggleComp('comp_foliage', true);
            const fa = comps['minecraft:foliage_appearance'];
            if (fa.color_map) setVal('foliage_color_map', fa.color_map);
            else setColor('foliage_color_hex_text', 'foliage_color_hex', fa.color);
        } else toggleComp('comp_foliage', false);

        // --- Grass ---
        if (comps['minecraft:grass_appearance']) {
            toggleComp('comp_grass', true);
            const ga = comps['minecraft:grass_appearance'];
            if (ga.color_map) setVal('grass_color_map', ga.color_map);
            else setColor('grass_color_hex_text', 'grass_color_hex', ga.color);
            $('grass_is_shaded').checked = !!ga.grass_is_shaded;
        } else toggleComp('comp_grass', false);

        // --- Vibrant Visuals (Unified Section) ---
        // Check if any vibrant visual component exists to enable the main toggle
        const hasVibrant = comps['minecraft:atmosphere_identifier'] || 
                           comps['minecraft:color_grading_identifier'] || 
                           comps['minecraft:cubemap_identifier'] || 
                           comps['minecraft:lighting_identifier'] || 
                           comps['minecraft:water_identifier'];

        if (hasVibrant) {
            toggleComp('comp_vibrant_visuals', true);
            
            if(comps['minecraft:atmosphere_identifier']) 
                setVal('vibrant_atmosphere', comps['minecraft:atmosphere_identifier'].atmosphere_identifier);
                
            if(comps['minecraft:color_grading_identifier']) 
                setVal('vibrant_color_grading', comps['minecraft:color_grading_identifier'].color_grading_identifier);
                
            if(comps['minecraft:cubemap_identifier']) 
                setVal('vibrant_cubemap', comps['minecraft:cubemap_identifier'].cubemap_identifier);
                
            if(comps['minecraft:lighting_identifier']) 
                setVal('vibrant_lighting', comps['minecraft:lighting_identifier'].lighting_identifier);
                
            if(comps['minecraft:water_identifier']) 
                setVal('vibrant_water', comps['minecraft:water_identifier'].water_identifier);
                
        } else {
            toggleComp('comp_vibrant_visuals', false);
        }


        // --- Dry Foliage ---
        if (comps['minecraft:dry_foliage_color']) {
            toggleComp('comp_dry_foliage', true);
            const df = comps['minecraft:dry_foliage_color'].color;
            if (Array.isArray(df)) setVal('dry_foliage_array', JSON.stringify(df));
            else setColor('dry_foliage_hex_text', 'dry_foliage_hex', df);
        } else toggleComp('comp_dry_foliage', false);

        // --- Precipitation ---
        if (comps['minecraft:precipitation']) {
            toggleComp('comp_precip', true);
            const p = comps['minecraft:precipitation'];
            // Check if it is advanced (multiple keys) or single
            const keys = Object.keys(p);
            const complexKeys = ['ash', 'blue_spores', 'red_spores', 'white_ash'];
            const isAdvanced = keys.some(k => complexKeys.includes(k));

            if (isAdvanced) {
                setVal('precip_mode', 'advanced');
                $('precip_mode').dispatchEvent(new Event('change'));
                complexKeys.forEach(k => setVal(`precip_${k}`, p[k]));
            } else {
                setVal('precip_mode', 'single');
                $('precip_mode').dispatchEvent(new Event('change'));
                if (keys.length > 0) {
                    setVal('precip_type', keys[0]);
                    setVal('precip_density', p[keys[0]]);
                }
            }
        } else toggleComp('comp_precip', false);

        // --- Ambient Sounds ---
        if (comps['minecraft:ambient_sounds']) {
            toggleComp('comp_ambient', true);
            const as = comps['minecraft:ambient_sounds'];
            setVal('ambient_loop', as.loop);
            setVal('ambient_mood', as.mood);
            if (as.addition) {
                setVal('ambient_add_asset', as.addition.asset);
                const el_amb = document.getElementById('ambient_add_chance');
if (ambient.ambient_add_chance !== undefined) {
    el_amb.value = ambient.ambient_add_chance;
    if (el_amb.updateSliderUI) el_amb.updateSliderUI(); // <-- NEW LINE for slider update
}

            }
            
            // Underwater
            if (as.underwater_loop || as.underwater_mood || as.underwater_addition) {
                toggleComp('comp_underwater_ambient', true);
                setVal('underwater_loop', as.underwater_loop);
                setVal('underwater_mood', as.underwater_mood);
                if (as.underwater_addition) {
                    setVal('underwater_add_asset', as.underwater_addition.asset);
                    const el_uw = document.getElementById('underwater_add_chance');
if (as.underwater_addition && as.underwater_addition.chance !== undefined) {
    el_uw.value = as.underwater_addition.chance;
    if (el_uw.updateSliderUI) el_uw.updateSliderUI(); // <-- Essential for slider
}

                }
            } else {
                toggleComp('comp_underwater_ambient', false);
            }
        } else toggleComp('comp_ambient', false);

        // --- Music ---
        if (comps['minecraft:biome_music']) {
            toggleComp('comp_music', true);
            const bm = comps['minecraft:biome_music'];
            setVal('music_definition', bm.music_definition);
            const el_mus = document.getElementById('music_volume');
if (bm.volume_multiplier !== undefined) {
    el_mus.value = bm.volume_multiplier;
    if (el_mus.updateSliderUI) el_mus.updateSliderUI(); // <-- Essential for slider
}

            if (bm.underwater_music !== undefined) {
                setVal('music_underwater', bm.underwater_music.toString());
            }
        } else toggleComp('comp_music', false);

        alert("Client Biome imported successfully!");

    } catch (e) {
        alert("Error importing Client JSON: " + e.message);
        console.error(e);
    }
}

// --- Download .mcaddon Event Listener ---
document.getElementById('downloadMcaddonButton').addEventListener('click', async () => {
    // 1. Gather Data
    const serverJsonText = document.getElementById('jsonOutput').textContent;
    const clientJsonText = document.getElementById('outputJson').textContent; 
    const identifier = document.getElementById('identifier').value.trim().toLowerCase();

    // 2. Validation: Only Server Biome is strictly required now
    if (!serverJsonText) {
        alert("Please generate the Server Biome first.");
        return;
    }
    
    if (!identifier || !/^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/.test(identifier)) {
        alert("Invalid Identifier. Please ensure it matches namespace:name pattern.");
        return;
    }

    // 3. Parse Data
    let serverData, clientData;
    try {
        serverData = JSON.parse(serverJsonText);
        // Only parse client data if it exists
        if (clientJsonText && clientJsonText.trim()) {
            clientData = JSON.parse(clientJsonText);
        }
    } catch (e) {
        alert("Error parsing JSON data. Please regenerate.");
        return;
    }

    // Check if we need a Resource Pack (Client Data OR Fogs exist)
    const hasFogs = window.sessionFogs && Object.keys(window.sessionFogs).length > 0;
    const hasClient = !!clientData || hasFogs;

    // 4. Prepare File Names & IDs
    const namePart = identifier.split(':')[1] || identifier;
    const cleanName = namePart.replace(/[^a-z0-9._-]/g, '_');
    const packName = `Wanxian_${cleanName}`;
    
    // Generate UUIDs
    const bpHeaderUuid = generateUuidv4();
    const bpModuleUuid = generateUuidv4();
    const rpHeaderUuid = generateUuidv4();
    const rpModuleUuid = generateUuidv4();

    const zip = new JSZip();

    // 5. Create Behavior Pack (BP) Structure
    const bpFolder = zip.folder(packName + "_BP");
    
    const bpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} BP`,
            "description": "Behavior Pack generated by Wanxian",
            "uuid": bpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 0]
        },
        "modules": [{ "type": "data", "uuid": bpModuleUuid, "version": [1, 0, 0] }]
    };

    // Only add dependency if we are actually creating an RP
    if (hasClient) {
        bpManifest.dependencies = [{ "uuid": rpHeaderUuid, "version": [1, 0, 0] }];
    }

    bpFolder.file("manifest.json", JSON.stringify(bpManifest, null, 2));
    const bpBiomesFolder = bpFolder.folder("biomes");
    bpBiomesFolder.file(`${cleanName}.biome.json`, serverJsonText);

    // 6. Create Resource Pack (RP) Structure (Only if needed)
    if (hasClient) {
        const rpFolder = zip.folder(packName + "_RP");
        
        // Add Custom Fogs
        if (window.addFogsToZip) window.addFogsToZip(rpFolder);

        const rpManifest = {
            "format_version": 2,
            "header": {
                "name": `${packName} RP`,
                "description": "Resource Pack generated by Wanxian",
                "uuid": rpHeaderUuid,
                "version": [1, 0, 0],
                "min_engine_version": [1, 21, 0]
            },
            "modules": [{ "type": "resources", "uuid": rpModuleUuid, "version": [1, 0, 0] }],
            "dependencies": [{ "uuid": bpHeaderUuid, "version": [1, 0, 0] }]
        };

        rpFolder.file("manifest.json", JSON.stringify(rpManifest, null, 2));
        
        // Add Client Biome File if available
        if (clientData) {
            const rpBiomesFolder = rpFolder.folder("biomes");
            rpBiomesFolder.file(`${cleanName}.client_biome.json`, JSON.stringify(clientData, null, 2));
        }

        // Add Icon to RP
        try {
            const response = await fetch('icons/icon3.png');
            if (response.ok) {
                const blob = await response.blob();
                rpFolder.file("pack_icon.png", blob);
            }
        } catch (e) { console.warn("Could not fetch pack icon.", e); }
    }

    // 7. Add Icon to BP
    try {
        const response = await fetch('icons/icon3.png');
        if (response.ok) {
            const blob = await response.blob();
            bpFolder.file("pack_icon.png", blob);
        }
    } catch (e) { console.warn("Could not fetch pack icon.", e); }

    // 8. Export
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName}.mcaddon`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showSnackbar("Successfully exported .mcaddon!");
    } catch (error) {
        alert(`Failed to create .mcaddon: ${error.message}`);
    }
});


</script>

<script>
    /**
 * M3 Expressive Multi-Select Initializer
 * Automatically converts existing <select multiple> elements into M3 UI.
 */
function initMultiSelects() {
    const selects = document.querySelectorAll('select[multiple]');

    selects.forEach(select => {
        // Check if already processed
        if (select.dataset.m3Initialized) return;
        select.dataset.m3Initialized = "true";

        // Hide native select
        select.style.display = 'none';

        // Create Trigger UI
        const trigger = document.createElement('div');
        trigger.className = 'm3-select-trigger';
        
        const textSpan = document.createElement('span');
        textSpan.className = 'selection-text placeholder';
        textSpan.textContent = 'Select options...';
        
        const icon = document.createElement('span');
        icon.className = 'material-symbols-rounded';
        icon.textContent = '';
        icon.style.color = 'var(--md-sys-color-primary)';

        trigger.appendChild(textSpan);
        trigger.appendChild(icon);
        select.parentNode.insertBefore(trigger, select.nextSibling);

        // Initialize Trigger Text based on current selection
        updateTriggerText(select, textSpan);

        // Create Modal DOM (One per select for simplicity in state management)
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'm3-select-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'm3-select-modal';

        // Modal Header
        const header = document.createElement('div');
        header.className = 'm3-modal-header';
        header.innerHTML = `
            <h3>Select</h3>
            <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary)">check_circle</span>
        `;

        // Modal Controls (Search + Select All)
        const controls = document.createElement('div');
        controls.className = 'm3-modal-controls';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.className = 'm3-search-input';
        searchInput.placeholder = 'Search options...';

        const toggleAllBtn = document.createElement('button');
        toggleAllBtn.type = 'button';
        toggleAllBtn.className = 'm3-toggle-all-btn';
        toggleAllBtn.title = "Select All / Deselect All";
        toggleAllBtn.innerHTML = '<span class="material-symbols-rounded">select_all</span>';

        controls.appendChild(searchInput);
        controls.appendChild(toggleAllBtn);

        // List Container
        const listContainer = document.createElement('div');
        listContainer.className = 'm3-modal-list';

        // Modal Footer
        const footer = document.createElement('div');
        footer.className = 'm3-modal-footer';
        
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'm3-modal-btn m3-btn-text';
        cancelBtn.textContent = 'Cancel';

        const okBtn = document.createElement('button');
        okBtn.type = 'button';
        okBtn.className = 'm3-modal-btn m3-btn-filled';
        okBtn.textContent = 'Okay';

        footer.appendChild(cancelBtn);
        footer.appendChild(okBtn);

        // Assemble Modal
        modal.appendChild(header);
        modal.appendChild(controls);
        modal.appendChild(listContainer);
        modal.appendChild(footer);
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);

        // State Variables
        let tempSelectedValues = new Set();

        // --- Event Listeners ---

        // Open Modal
        trigger.addEventListener('click', () => {
            // 1. Reset Temp State from Native Select
            tempSelectedValues.clear();
            Array.from(select.options).forEach(opt => {
                if (opt.selected) tempSelectedValues.add(opt.value);
            });

            // 2. Populate List
            renderList();
            
            // 3. Clear Search
            searchInput.value = '';
            filterList('');

            // 4. Show
            trigger.classList.add('active');
            modalOverlay.classList.add('open');
        });

        // Render List Function
        function renderList() {
            listContainer.innerHTML = '';
            Array.from(select.options).forEach(opt => {
                const item = document.createElement('div');
                item.className = 'm3-option-item';
                if (tempSelectedValues.has(opt.value)) item.classList.add('selected');
                
                item.dataset.value = opt.value;
                item.dataset.label = opt.text.toLowerCase(); // For search

                const checkbox = document.createElement('div');
                checkbox.className = 'm3-option-checkbox';
                
                const label = document.createElement('span');
                label.className = 'm3-option-label';
                label.textContent = opt.text;

                item.appendChild(checkbox);
                item.appendChild(label);
                listContainer.appendChild(item);

                // Toggle Item Click
                item.addEventListener('click', () => {
                    if (tempSelectedValues.has(opt.value)) {
                        tempSelectedValues.delete(opt.value);
                        item.classList.remove('selected');
                    } else {
                        tempSelectedValues.add(opt.value);
                        item.classList.add('selected');
                    }
                });
            });
        }

        // Search Function
        searchInput.addEventListener('input', (e) => {
            filterList(e.target.value.toLowerCase());
        });

        function filterList(query) {
            const items = listContainer.querySelectorAll('.m3-option-item');
            items.forEach(item => {
                const text = item.dataset.label;
                if (text.includes(query)) {
                    item.classList.remove('hidden');
                } else {
                    item.classList.add('hidden');
                }
            });
        }

        // Toggle All
        toggleAllBtn.addEventListener('click', () => {
            const visibleItems = Array.from(listContainer.querySelectorAll('.m3-option-item:not(.hidden)'));
            const allVisibleSelected = visibleItems.every(item => tempSelectedValues.has(item.dataset.value));

            if (allVisibleSelected) {
                // Deselect all visible
                visibleItems.forEach(item => {
                    tempSelectedValues.delete(item.dataset.value);
                    item.classList.remove('selected');
                });
            } else {
                // Select all visible
                visibleItems.forEach(item => {
                    tempSelectedValues.add(item.dataset.value);
                    item.classList.add('selected');
                });
            }
        });

        // Cancel
        cancelBtn.addEventListener('click', () => {
            modalOverlay.classList.remove('open');
            trigger.classList.remove('active');
        });

        // Okay (Save)
        okBtn.addEventListener('click', () => {
            // Apply to Native Select
            Array.from(select.options).forEach(opt => {
                opt.selected = tempSelectedValues.has(opt.value);
            });

            // Trigger Change Event (for listeners)
            select.dispatchEvent(new Event('change'));

            // Update UI Text
            updateTriggerText(select, textSpan);

            // Close
            modalOverlay.classList.remove('open');
            trigger.classList.remove('active');
        });

        // Close on Overlay Click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.classList.remove('open');
                trigger.classList.remove('active');
            }
        });
    });
}

// Helper to update the trigger text
function updateTriggerText(select, textSpan) {
    const selectedOptions = Array.from(select.selectedOptions);
    const count = selectedOptions.length;

    if (count === 0) {
        textSpan.textContent = 'Select options...';
        textSpan.classList.add('placeholder');
    } else if (count === 1) {
        textSpan.textContent = selectedOptions[0].text;
        textSpan.classList.remove('placeholder');
    } else {
        textSpan.textContent = `${count} items selected`;
        textSpan.classList.remove('placeholder');
    }
}

// Initialize on Load
document.addEventListener('DOMContentLoaded', initMultiSelects);

// Optional: Watch for dynamic form resets to clear UI
document.addEventListener('reset', (e) => {
    setTimeout(() => { // Wait for native reset to finish
        const selects = document.querySelectorAll('select[multiple]');
        selects.forEach(select => {
             if(select.nextSibling && select.nextSibling.classList && select.nextSibling.classList.contains('m3-select-trigger')) {
                 const textSpan = select.nextSibling.querySelector('.selection-text');
                 updateTriggerText(select, textSpan);
             }
        });
    }, 0);
});

</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
    const track = document.getElementById('fastScrollTrack');
    const thumb = document.getElementById('fastScrollThumb');
    
    let isDragging = false;
    let hideTimeout;
    let startY;
    let startTop;

    // Configuration
    const HEADER_OFFSET = 70; // Matches CSS top
    const BOTTOM_OFFSET = 10; // Matches CSS bottom
    
    // --- 1. Update Thumb Position on Page Scroll ---
    window.addEventListener('scroll', () => {
        if (isDragging) return; // Don't update if user is holding it

        // Show scrollbar
        track.classList.add('visible');
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
            if (!track.matches(':hover') && !isDragging) {
                track.classList.remove('visible');
            }
        }, 1500); // Hide after 1.5s of inactivity

        updateThumbPosition();
    });

    function updateThumbPosition() {
        const windowHeight = window.innerHeight;
        const docHeight = document.body.scrollHeight;
        const trackHeight = windowHeight - HEADER_OFFSET - BOTTOM_OFFSET;
        const thumbHeight = thumb.offsetHeight;
        
        const scrollPercent = window.scrollY / (docHeight - windowHeight);
        
        // Calculate top position limited by track bounds
        const topPos = scrollPercent * (trackHeight - thumbHeight);
        
        thumb.style.top = `${Math.max(0, Math.min(topPos, trackHeight - thumbHeight))}px`;
    }

    // --- 2. Handle Dragging Logic ---

    function startDrag(e) {
        e.preventDefault();
        isDragging = true;
        thumb.classList.add('dragging');
        track.classList.add('visible');
        
        // Get initial Y position (Mouse or Touch)
        startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        startTop = parseFloat(thumb.style.top || 0);
        
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchend', stopDrag);
    }

    function onDrag(e) {
        if (!isDragging) return;
        e.preventDefault(); // Prevent text selection/native scroll

        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        const deltaY = clientY - startY;
        let newTop = startTop + deltaY;

        // Metrics
        const windowHeight = window.innerHeight;
        const docHeight = document.body.scrollHeight;
        const trackHeight = windowHeight - HEADER_OFFSET - BOTTOM_OFFSET;
        const thumbHeight = thumb.offsetHeight;
        const maxTop = trackHeight - thumbHeight;

        // Clamp values
        if (newTop < 0) newTop = 0;
        if (newTop > maxTop) newTop = maxTop;

        // Move Thumb visually immediately
        thumb.style.top = `${newTop}px`;

        // Scroll Page
        const scrollPercent = newTop / maxTop;
        const scrollToY = scrollPercent * (docHeight - windowHeight);
        
        window.scrollTo(0, scrollToY);
    }

    function stopDrag() {
        isDragging = false;
        thumb.classList.remove('dragging');
        
        // Cleanup listeners
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchend', stopDrag);
        
        // Start hide timer
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
            if (!track.matches(':hover')) {
                track.classList.remove('visible');
            }
        }, 1000);
    }

    // Attach Listeners
    thumb.addEventListener('mousedown', startDrag);
    thumb.addEventListener('touchstart', startDrag, { passive: false });
    
    // Initial Position
    updateThumbPosition();
    
    // Resize Observer to adjust if window size changes
    window.addEventListener('resize', updateThumbPosition);
});

</script>

<script>
/* --- Theme Management System (Loads from themes.js) --- */

function getThemePalettes() {
    // Check if external file loaded
    if (window.THEME_PALETTES) {
        return window.THEME_PALETTES;
    }
    console.warn("themes.js not loaded. Theme picker will be empty.");
    return {};
}

// 1. Logic to Apply Theme
function applyThemePalette(themeKey) {
    const palettes = getThemePalettes();
    const theme = palettes[themeKey];
    if (!theme) return;

    let styleTag = document.getElementById('dynamic-theme-styles');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'dynamic-theme-styles';
        document.head.appendChild(styleTag);
    }

    // Convert object to CSS string
    const rulesToCss = (rules) => Object.entries(rules).map(([k, v]) => `${k}: ${v};`).join(' ');

    styleTag.textContent = `
        :root {
            ${rulesToCss(theme.light)}
        }
        .dark-theme {
            ${rulesToCss(theme.dark)}
        }
    `;

    // Save to storage
    localStorage.setItem('selectedThemeKey', themeKey);
    
    // Update Active UI State
    document.querySelectorAll('.theme-option').forEach(el => {
        if (el.dataset.theme === themeKey) el.classList.add('active');
        else el.classList.remove('active');
    });
}

// 2. Render Theme UI
function initThemePicker() {
    const container = document.getElementById('themeListContainer');
    if (!container) return; // Guard clause
    
    container.innerHTML = '';
    const palettes = getThemePalettes();

    Object.keys(palettes).forEach(key => {
        const t = palettes[key];
        
        const card = document.createElement('div');
        card.className = 'theme-option';
        card.dataset.theme = key;
        
        // CSS vars for this specific preview circle
        card.style.setProperty('--preview-primary', t.preview.primary);
        card.style.setProperty('--preview-secondary', t.preview.secondary);
        card.style.setProperty('--preview-tertiary', t.preview.tertiary);
        card.style.setProperty('--preview-surface', t.preview.surface);

        card.innerHTML = `
            <div class="theme-preview-circle"></div>
            <div class="theme-label">${t.name}</div>
        `;

        card.addEventListener('click', () => {
            applyThemePalette(key);
        });

        container.appendChild(card);
    });

    // Load saved theme
    const saved = localStorage.getItem('selectedThemeKey') || 'default';
    if(palettes[saved]) {
        applyThemePalette(saved);
    } else {
        applyThemePalette('default');
    }
}

// 3. Initialize Listeners
document.addEventListener('DOMContentLoaded', () => {
    initThemePicker();

    // Theme Modal Toggles
    const themeBtn = document.getElementById('theme-button');
    const themeModal = document.getElementById('themeModalOverlay');
    const themeClose = document.getElementById('closeThemeModal');

    if(themeBtn && themeModal && themeClose) {
        themeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation(); 
            const dropdown = document.getElementById('dropdown-menu');
            if(dropdown) dropdown.classList.remove('visible');
            themeModal.style.display = 'flex';
        });

        themeClose.addEventListener('click', () => {
            themeModal.style.display = 'none';
        });

        themeModal.addEventListener('click', (e) => {
            if (e.target === themeModal) themeModal.style.display = 'none';
        });
    }
});


</script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const unusedToggle = document.getElementById('show_unused_components');
        const unusedWrapper = document.getElementById('unused_components_wrapper');

        if (unusedToggle && unusedWrapper) {
            unusedToggle.addEventListener('change', () => {
                unusedWrapper.style.display = unusedToggle.checked ? 'block' : 'none';
            });
        }
    });
</script>
<script>
// Define global initialization function for sliders
window.initCustomSlider = function(wrapper) {
    const targetId = wrapper.dataset.targetId;
    const targetInput = document.getElementById(targetId);
    if (!targetInput) return;

    const minValue = parseFloat(wrapper.dataset.minValue);
    const maxValue = parseFloat(wrapper.dataset.maxValue);
    const decimalPlaces = parseInt(wrapper.dataset.decimalPlaces);
    
    // Grab initial value from the hidden input
    let initialVal = parseFloat(targetInput.value);
    if (isNaN(initialVal)) initialVal = parseFloat(wrapper.dataset.initialValue);

    // Build HTML
    wrapper.innerHTML = `
        <div class="slider-info">
            <span>Value</span>
            <span class="slider-val-display">${initialVal.toFixed(decimalPlaces)}</span>
        </div>
        <div class="color-bars-container">
            <div class="color-bar" id="left-bar"></div>
            <div id="separator-handle"></div>
            <div class="color-bar" id="right-bar"></div>
        </div>
    `;

    const container = wrapper.querySelector('.color-bars-container');
    const leftBar = wrapper.querySelector('#left-bar');
    const rightBar = wrapper.querySelector('#right-bar');
    const displayVal = wrapper.querySelector('.slider-val-display');

    // Update UI Function
    const updateSliderUI = (val) => {
        // Clamp value
        if (val < minValue) val = minValue;
        if (val > maxValue) val = maxValue;

        const range = maxValue - minValue;
        const percent = ((val - minValue) / range) * 100;

        leftBar.style.width = `calc((100% - 16px) * ${percent / 100})`; 
        rightBar.style.width = `calc((100% - 16px) * ${(100 - percent) / 100})`;
        
        displayVal.textContent = val.toFixed(decimalPlaces);
        
        // Toggle Dot visibility
        if ((100 - percent) < 5) rightBar.classList.add('hide-dot');
        else rightBar.classList.remove('hide-dot');
        
        // Sync to hidden input
        targetInput.value = val.toFixed(decimalPlaces);
    };

    // Attach method to input so other scripts can call it
    targetInput.updateSliderUI = () => {
            const v = parseFloat(targetInput.value);
            if(!isNaN(v)) updateSliderUI(v);
    };

    // Drag Logic
    let isDragging = false;
    const onDrag = (clientX) => {
        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        let percent = x / rect.width;
        if (percent < 0) percent = 0; 
        if (percent > 1) percent = 1;
        
        const range = maxValue - minValue;
        const newVal = minValue + (percent * range);
        updateSliderUI(newVal);
    };

    const startDrag = (e) => {
        isDragging = true; 
        e.preventDefault();
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchmove', moveDrag, {passive: false});
        document.addEventListener('touchend', endDrag);
    };
    
    const moveDrag = (e) => {
        if(!isDragging) return;
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        onDrag(cx);
    };
    
    const endDrag = () => {
        isDragging = false;
        document.removeEventListener('mousemove', moveDrag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchmove', moveDrag);
        document.removeEventListener('touchend', endDrag);
    };

    const handle = wrapper.querySelector('#separator-handle');
    handle.addEventListener('mousedown', startDrag);
    handle.addEventListener('touchstart', startDrag, {passive: false});
    container.addEventListener('click', (e) => { if(e.target !== handle) onDrag(e.clientX); });

    // Init
    updateSliderUI(initialVal);
};

// Initialize static sliders on load
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.custom-slider-replacement').forEach(window.initCustomSlider);
});
</script>

<script>
/**
 * FOG SYSTEM LOGIC - COMPLETE & FIXED
 * Handles Dynamic Fog Creator, Import, Export, and Storage.
 */

// Global Variables
window.sessionFogs = {};
const FOG_STORAGE_KEY = 'bibuild_saved_fogs'; 

// Data model to hold the form state while editing
if (typeof currentFogData === 'undefined') {
    var currentFogData = {}; 
}
let currentActiveTab = 'general';

const DEFAULT_FOG_DATA = {
    identifier: "custom:new_fog",
    distance: {
        air: { enabled: true, color: "#AABBCC", start: 0, end: 64, type: "render" },
        water: { enabled: false, color: "#4455FF", start: 0, end: 15, type: "render" },
        weather: { enabled: false, color: "#666666", start: 0, end: 32, type: "render" },
        lava: { enabled: false, color: "#FF4400", start: 0, end: 2, type: "fixed" },
        lava_resistance: { enabled: false, color: "#FF4400", start: 0, end: 10, type: "fixed" },
        powder_snow: { enabled: false, color: "#FFFFFF", start: 0, end: 2, type: "fixed" }
    }
};

// --- Helper Functions ---

function updateColorInputUI(textInput, colorPicker, defaultColor = '#000000') {
    const applyColor = (color) => { colorPicker.value = color || '#000000'; };
    const parseColor = (val) => {
        if(!val) return null;
        val = val.trim();
        return val; 
    };

    const initialParsedColor = parseColor(textInput.value);
    applyColor(initialParsedColor || defaultColor);
    
    textInput.addEventListener('input', () => {
        const c = parseColor(textInput.value);
        if(c) applyColor(c);
    });
    
    colorPicker.addEventListener('input', () => { 
        textInput.value = colorPicker.value.toUpperCase(); 
        textInput.dispatchEvent(new Event('input')); 
    });
}

function setFogColorInput(hex) {
    const text = document.getElementById('fog_dist_color_text');
    const picker = document.getElementById('fog_dist_color_picker');
    text.value = hex;
    picker.value = hex;
}

function downloadObjectAsJson(exportObj, exportName){
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObj, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href",     dataStr);
    downloadAnchorNode.setAttribute("download", exportName);
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function handleFileImport(file, callback) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const json = JSON.parse(e.target.result);
            callback(json);
        } catch (err) {
            alert("Invalid JSON file.");
        }
    };
    reader.readAsText(file);
}

function registerFog(json) {
    const id = json['minecraft:fog_settings'].description.identifier;
    window.sessionFogs[id] = {
        content: json,
        fileName: id.split(':')[1].replace(/[^a-z0-9._-]/g, '_')
    };
    document.getElementById('fog_identifier').value = id;
    return id;
}

// --- Main Initialization ---

document.addEventListener('DOMContentLoaded', () => {
    initFogSystem();
});

function initFogSystem() {
    const modal = document.getElementById('fogCreatorModalOverlay');
    const identifierInput = document.getElementById('fog_identifier'); 

    // Initialize Color Picker in Modal
    const distColorText = document.getElementById('fog_dist_color_text');
    const distColorPicker = document.getElementById('fog_dist_color_picker');
    if(distColorText && distColorPicker) {
        updateColorInputUI(distColorText, distColorPicker);
    }

    // --- Tab Navigation ---
    document.querySelectorAll('.fog-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            saveCurrentTabToMemory();
            document.querySelectorAll('.fog-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            const target = tab.dataset.tab;
            currentActiveTab = target;
            renderFogFormTab(target);
        });
    });

    // --- Main Page Buttons ---

    // Import Button
    document.getElementById('btn_import_fog_file').addEventListener('click', () => {
        document.getElementById('fog_file_input').click();
    });

    document.getElementById('fog_file_input').addEventListener('change', (e) => {
        handleFileImport(e.target.files[0], (json) => {
            registerFog(json);
            showSnackbar("Fog file imported!");
        });
        e.target.value = '';
    });

    // Open Creator
    document.getElementById('btn_open_fog_creator').addEventListener('click', () => {
        const currentId = identifierInput.value.trim();
        
        // Logic: Use saved session if exists, otherwise create new
        if (currentId && window.sessionFogs[currentId]) {
            parseJsonToFogData(window.sessionFogs[currentId].content);
        } else {
            currentFogData = JSON.parse(JSON.stringify(DEFAULT_FOG_DATA));
            
            // FIX: If user typed an ID in the main box, enforce it on the new object
            if (currentId) {
                currentFogData.identifier = currentId;
            }
        }

        // Reset to first tab
        currentActiveTab = 'general';
        document.querySelectorAll('.fog-tab').forEach(t => t.classList.remove('active'));
        document.querySelector('.fog-tab[data-tab="general"]').classList.add('active');
        renderFogFormTab('general');
        
        modal.style.display = 'flex';
    });


    // --- Modal Buttons ---

    // Import JSON (Top Right)
    document.getElementById('btn_fog_import_json').addEventListener('click', () => {
        document.getElementById('fog_creator_import_input').click();
    });

    document.getElementById('fog_creator_import_input').addEventListener('change', (e) => {
        handleFileImport(e.target.files[0], (json) => {
            parseJsonToFogData(json);
            renderFogFormTab(currentActiveTab);
            showSnackbar("JSON Imported into editor");
        });
        e.target.value = '';
    });

    // Toggle Distance Fog
    document.getElementById('fog_dist_enable').addEventListener('change', (e) => {
        const fields = document.getElementById('fog_dist_fields');
        const msg = document.getElementById('fog_dist_disabled_msg');
        if (e.target.checked) {
            fields.style.display = 'block';
            msg.style.display = 'none';
        } else {
            fields.style.display = 'none';
            msg.style.display = 'block';
        }
    });

    // Export (Download)
    document.getElementById('btn_fog_export_file').addEventListener('click', () => {
        saveCurrentTabToMemory(); 
        const json = generateFogJsonFromData();
        const fileName = (currentFogData.identifier.split(':')[1] || "fog") + ".json";
        downloadObjectAsJson(json, fileName);
    });

    // Cancel
    document.getElementById('btn_fog_cancel').addEventListener('click', () => {
        modal.style.display = 'none';
    });

    // Okay (Save)
    document.getElementById('btn_fog_save_memory').addEventListener('click', () => {
        saveCurrentTabToMemory();
        
        if(!currentFogData.identifier || currentFogData.identifier.length < 3) {
            alert("Please enter a valid Fog Identifier.");
            return;
        }

        const json = generateFogJsonFromData();
        registerFog(json);
        modal.style.display = 'none';
        showSnackbar("Fog configuration saved!");
    });
}

// --- Logic: Rendering & Data ---

function renderFogFormTab(tabName) {
    document.getElementById('tab_content_general').style.display = 'none';
    document.getElementById('fog_distance_container').style.display = 'none';

    if (tabName === 'general') {
        document.getElementById('tab_content_general').style.display = 'block';
        document.getElementById('fog_form_id').value = currentFogData.identifier;
    } else {
        const container = document.getElementById('fog_distance_container');
        container.style.display = 'block';
        document.getElementById('fog_dist_title').textContent = tabName.replace('_', ' ') + " Fog";
        
        const data = currentFogData.distance[tabName] || { enabled: false };
        
        document.getElementById('fog_dist_enable').checked = data.enabled;
        
        // Refresh visibility
        const fields = document.getElementById('fog_dist_fields');
        const msg = document.getElementById('fog_dist_disabled_msg');
        if (data.enabled) {
            fields.style.display = 'block';
            msg.style.display = 'none';
        } else {
            fields.style.display = 'none';
            msg.style.display = 'block';
        }

        setFogColorInput(data.color || '#FFFFFF');
        document.getElementById('fog_dist_start').value = data.start !== undefined ? data.start : 0;
        document.getElementById('fog_dist_end').value = data.end !== undefined ? data.end : 10;
        document.getElementById('fog_dist_type').value = data.type || 'render';
    }
}

function saveCurrentTabToMemory() {
    if (currentActiveTab === 'general') {
        const val = document.getElementById('fog_form_id').value.trim();
        if(val) currentFogData.identifier = val;
    } else {
        const tab = currentActiveTab;
        const enabled = document.getElementById('fog_dist_enable').checked;
        currentFogData.distance[tab] = {
            enabled: enabled,
            color: document.getElementById('fog_dist_color_text').value,
            start: parseFloat(document.getElementById('fog_dist_start').value) || 0,
            end: parseFloat(document.getElementById('fog_dist_end').value) || 0,
            type: document.getElementById('fog_dist_type').value
        };
    }
}

function parseJsonToFogData(json) {
    const settings = json['minecraft:fog_settings'];
    if (!settings) return;

    currentFogData.identifier = settings.description?.identifier || "";
    const dist = settings.distance || {};
    const types = ['air', 'water', 'weather', 'lava', 'lava_resistance', 'powder_snow'];

    types.forEach(type => {
        if (dist[type]) {
            currentFogData.distance[type] = {
                enabled: true,
                color: dist[type].fog_color || "#FFFFFF",
                start: dist[type].fog_start || 0,
                end: dist[type].fog_end || 0,
                type: dist[type].render_distance_type || "render"
            };
        } else {
             currentFogData.distance[type] = { enabled: false, color: "#FFFFFF", start: 0, end: 10, type: "render" };
        }
    });
}

function generateFogJsonFromData() {
    const json = {
        "format_version": "1.16.0",
        "minecraft:fog_settings": {
            "description": { "identifier": currentFogData.identifier },
            "distance": {}
        }
    };

    const types = ['air', 'water', 'weather', 'lava', 'lava_resistance', 'powder_snow'];
    let hasAny = false;

    types.forEach(type => {
        const d = currentFogData.distance[type];
        if (d && d.enabled) {
            hasAny = true;
            json['minecraft:fog_settings'].distance[type] = {
                "fog_color": d.color,
                "fog_start": d.start,
                "fog_end": d.end,
                "render_distance_type": d.type
            };
        }
    });

    if(!hasAny) {
        json['minecraft:fog_settings'].distance['air'] = {
            "fog_color": "#ffffff", "fog_start": 0, "fog_end": 64, "render_distance_type": "render"
        };
    }

    return json;
}

// Hook for Main Export
window.addFogsToZip = function(zipFolder) {
    const fogIds = Object.keys(window.sessionFogs);
    if (fogIds.length === 0) return;
    const fogsFolder = zipFolder.folder("fogs");
    fogIds.forEach(id => {
        const data = window.sessionFogs[id];
        fogsFolder.file(data.fileName + ".json", JSON.stringify(data.content, null, 2));
    });
};
</script>

<script>
/**
 * DECORATIVE PRESETS SYSTEM - FINAL
 */

// --- 1. DATA ---

// --- 2. GLOBAL STATE ---
const activeDecorationIds = new Set(); // Always starts empty (No saving of items)

document.addEventListener('DOMContentLoaded', () => {
    initDecorationSystem();
});

function initDecorationSystem() {
    const toggleBtn = document.getElementById('decorative-presets-toggle');
    const toggleIcon = toggleBtn.querySelector('.trailing-icon-button');
    const toggleIconSymbol = toggleIcon.querySelector('.material-symbols-rounded');
    const section = document.getElementById('decoration-presets-section');
    const manageBtn = document.getElementById('btn_manage_decorations');
    const modal = document.getElementById('decorationModalOverlay');
    const closeBtn = document.getElementById('btn_close_decorations');
    const searchInput = document.getElementById('decoration_search');
    
    // Storage Key for Toggle Button Only
    const DECO_TOGGLE_KEY = 'bibuild_deco_toggle';

    function setToggleState(isOn) {
        toggleIcon.setAttribute('data-toggled', isOn ? 'on' : 'off');
        toggleIconSymbol.textContent = isOn ? 'toggle_on' : 'toggle_off';
        toggleIconSymbol.style.color = isOn ? 'var(--md-sys-color-primary)' : 'var(--md-sys-color-on-surface-variant)';
        section.style.display = isOn ? 'block' : 'none';
    }

    // Toggle Click
    toggleBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const isToggled = toggleIcon.getAttribute('data-toggled') === 'on';
        setToggleState(!isToggled);
        localStorage.setItem(DECO_TOGGLE_KEY, !isToggled ? 'on' : 'off');
        document.getElementById('dropdown-menu').classList.remove('visible');
    });

    // Modal Open
    manageBtn.addEventListener('click', () => {
        renderDecorationCategories();
        renderDecorationItems(DECORATIVE_PRESETS_DATA[0].id);
        modal.style.display = 'flex';
    });

    // Modal Close
    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
        updateMainSectionCounter();
    });

    // Search
    searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        if(!query) {
            const activeCat = document.querySelector('.decoration-category.active');
            if(activeCat) renderDecorationItems(activeCat.dataset.id);
            return;
        }
        const results = [];
        DECORATIVE_PRESETS_DATA.forEach(cat => {
            cat.items.forEach(item => {
                if(item.name.toLowerCase().includes(query) || item.tags.some(t=>t.includes(query))) {
                    results.push(item);
                }
            });
        });
        renderCustomList(results);
    });

    // Restore Toggle State
    const savedState = localStorage.getItem(DECO_TOGGLE_KEY);
    setToggleState(savedState === 'on');
    
    updateMainSectionCounter();
}

// --- Render Logic ---

function renderDecorationCategories() {
    const container = document.getElementById('decoration_categories');
    container.innerHTML = '';
    DECORATIVE_PRESETS_DATA.forEach((cat, index) => {
        const div = document.createElement('div');
        div.className = `decoration-category ${index === 0 ? 'active' : ''}`;
        div.dataset.id = cat.id;
        const selectedCount = cat.items.filter(i => activeDecorationIds.has(i.id)).length;
        div.innerHTML = `<span>${cat.name}</span><span class="cat-badge" style="display:${selectedCount>0?'inline-block':'none'}">${selectedCount}</span>`;
        div.addEventListener('click', () => {
            document.querySelectorAll('.decoration-category').forEach(c => c.classList.remove('active'));
            div.classList.add('active');
            renderDecorationItems(cat.id);
        });
        container.appendChild(div);
    });
}

function renderDecorationItems(categoryId) {
    const category = DECORATIVE_PRESETS_DATA.find(c => c.id === categoryId);
    if (!category) return;
    renderCustomList(category.items);
}

function renderCustomList(items) {
    const container = document.getElementById('decoration_items_container');
    const emptyState = document.getElementById('decoration_empty_state');
    container.innerHTML = '';
    container.appendChild(emptyState); 

    if (items.length === 0) { emptyState.style.display = 'block'; return; }
    emptyState.style.display = 'none';

    items.forEach(item => {
        const el = document.createElement('div');
        el.className = 'decoration-item';
        const isChecked = activeDecorationIds.has(item.id);

        el.innerHTML = `
            <div class="checkbox-wrapper">
                <input type="checkbox" ${isChecked ? 'checked' : ''} style="pointer-events: none;"> 
            </div>
            <div class="info">
                <div class="name">${item.name}<span class="files-count">${item.files.length} files</span></div>
                <div class="tags">Tags: ${item.tags.join(', ')}</div>
            </div>`;

        el.addEventListener('click', () => {
            const checkbox = el.querySelector('input');
            const newState = !checkbox.checked;
            checkbox.checked = newState;
            if (newState) activeDecorationIds.add(item.id);
            else activeDecorationIds.delete(item.id);
            updateCounters();
        });
        container.appendChild(el);
    });
}

function updateCounters() {
    document.getElementById('decoration_total_counter').textContent = activeDecorationIds.size;
    document.querySelectorAll('.decoration-category').forEach(el => {
        const catId = el.dataset.id;
        const cat = DECORATIVE_PRESETS_DATA.find(c => c.id === catId);
        const count = cat.items.filter(i => activeDecorationIds.has(i.id)).length;
        const badge = el.querySelector('.cat-badge');
        badge.textContent = count;
        badge.style.display = count > 0 ? 'inline-block' : 'none';
    });
}

function updateMainSectionCounter() {
    document.getElementById('decoration-active-count').textContent = `${activeDecorationIds.size} items selected`;
}

// --- EXPORT HOOKS ---

function getSelectedPresets() {
    const selected = [];
    DECORATIVE_PRESETS_DATA.forEach(cat => {
        cat.items.forEach(item => {
            if (activeDecorationIds.has(item.id)) selected.push(item);
        });
    });
    return selected;
}

// HOOK 1: Get Tags for JSON
window.getDecorationTags = function() {
    const presets = getSelectedPresets();
    const tags = new Set();
    presets.forEach(p => {
        if(p.tags) p.tags.forEach(t => tags.add(t));
    });
    return Array.from(tags);
};

// HOOK 2: Get Files for ZIP
window.addDecorationFilesToZip = async function(zipFolder) {
    // (Existing file fetch logic here...)
};
</script>

<script>
    /**
     * ADVANCED THEME COLOR SYNC
     * Ensures meta tag updates exactly when theme changes.
     */
    (function() {
        function applyThemeColor() {
            // We use a small timeout (50ms) to ensure the DOM and CSS variables 
            // have fully updated after the class change.
            setTimeout(() => {
                // Read from body to capture inherited variables
                const primaryColor = getComputedStyle(document.body)
                    .getPropertyValue('--md-sys-color-primary').trim();
                
                if (primaryColor) {
                    let metaTag = document.querySelector('meta[name="theme-color"]');
                    if (!metaTag) {
                        // Create if missing
                        metaTag = document.createElement('meta');
                        metaTag.name = "theme-color";
                        document.head.appendChild(metaTag);
                    }
                    // Apply
                    metaTag.setAttribute('content', primaryColor);
                }
            }, 50);
        }

        // 1. Initial Load
        applyThemeColor();
        window.addEventListener('load', applyThemeColor);

        // 2. Watch for automatic attribute changes (e.g. System Dark Mode)
        const observer = new MutationObserver(applyThemeColor);
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class', 'data-theme'] });
        observer.observe(document.body, { attributes: true, attributeFilter: ['class', 'data-theme'] });

        // 3. Direct Hook: Listen to the Toggle Button
        // This catches the user click immediately
        const themeToggleBtn = document.getElementById('theme-toggle');
        if (themeToggleBtn) {
            themeToggleBtn.addEventListener('click', applyThemeColor);
        }

        // 4. Direct Hook: Listen to Theme Modal Options
        // If you select a specific color theme from the modal
        const themeModal = document.getElementById('themeModalOverlay');
        if (themeModal) {
            themeModal.addEventListener('click', () => {
                // Allow a slightly longer delay for modal animations/selection logic
                setTimeout(applyThemeColor, 100); 
            });
        }
    })();
</script>


<script>
  function initVisualizer() {
    const container = document.getElementById('biome-visualizer');
    
    // Helper to safely get value
    const getVal = (id, def) => {
        const el = document.getElementById(id);
        return el ? (el.value || def) : def;
    };

    function updatePreview() {
        if(!container) return;

        // 1. Get Values
        const sky = getVal('sky_color_hex', '#88AAFF');
        const water = getVal('water_surface_color', '#4455FF');
        const waterAlpha = document.getElementById('water_surface_opacity') ? document.getElementById('water_surface_opacity').value : 0.8;
        const foliage = getVal('foliage_color_hex', '#55AA33');
        const grass = getVal('grass_color_hex', '#77CC44');

        // 2. Set CSS Variables (The Scene updates automatically via CSS)
        container.style.setProperty('--viz-sky', sky);
        container.style.setProperty('--viz-water', water);
        container.style.setProperty('--viz-water-alpha', waterAlpha);
        container.style.setProperty('--viz-foliage', foliage);
        container.style.setProperty('--viz-grass', grass);
    }

    // 3. Attach Listeners
    const ids = [
        'sky_color_hex', 'sky_color_hex_text',
        'water_surface_color', 'water_surface_color_text', 'water_surface_opacity',
        'foliage_color_hex', 'foliage_color_hex_text',
        'grass_color_hex', 'grass_color_hex_text'
    ];

    ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('input', updatePreview);
            el.addEventListener('change', updatePreview);
        }
    });

    // Run immediately
    updatePreview();
}

// Add to DOM Content Loaded
document.addEventListener('DOMContentLoaded', initVisualizer);
  
</script>
	</body>
</html>
